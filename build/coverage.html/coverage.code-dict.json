{"/home/travis/build/npmtest/node-npmtest-duo/test.js":"/* istanbul instrument in package npmtest_duo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-duo/lib.npmtest_duo.js":"/* istanbul instrument in package npmtest_duo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_duo = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_duo = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-duo/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-duo && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_duo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_duo\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_duo.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_duo.rollup.js'] =\n            local.assetsDict['/assets.npmtest_duo.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_duo.__dirname + '/lib.npmtest_duo.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo/lib/duo.js":"\n/**\n * Module dependencies.\n */\n\nvar Emitter = require('events').EventEmitter;\nvar clone = require('component-clone');\nvar stoj = require('duo-string-to-js');\nvar compat = require('duo-css-compat');\nvar parallel = require('co-parallel');\nvar Package = require('duo-package');\nvar debug = require('debug')('duo');\nvar filedeps = require('file-deps');\nvar exists = require('co-exists');\nvar extend = require('extend.js');\nvar parse = require('duo-parse');\nvar unyield = require('unyield');\nvar thunk = require('thunkify');\nvar cache = require('./cache');\nvar Pack = require('duo-pack');\nvar main = require('duo-main');\nvar mkdir = require('mkdirp');\nvar hasha = require('hasha');\nvar File = require('./file');\nvar Ware = require('ware');\nvar path = require('path');\nvar util = require('util');\nvar fs = require('co-fs');\nvar cp = require('cp');\n\nvar basename = path.basename;\nvar relative = path.relative;\nvar extname = path.extname;\nvar dirname = path.dirname;\nvar resolve = path.resolve;\nvar join = path.join;\nvar fmt = util.format;\nvar slice = [].slice;\n\n/**\n * Thunks.\n */\n\nmkdir = thunk(mkdir);\ncp = thunk(cp);\n\n/**\n * Export `Duo`.\n */\n\nmodule.exports = Duo;\n\n/**\n * Initialize a new `Duo` package with the path to the package's `root` folder.\n *\n * @param {String} root\n * @return {Duo}\n * @api public\n */\n\nfunction Duo(root) {\n  if (!(this instanceof Duo)) return new Duo(root);\n  if (!root) throw error('duo requires a root directory');\n  Emitter.call(this);\n  this.root(root);\n  this.manifest('component.json');\n  this.installTo('components');\n  this.buildTo('build');\n  this.copy(false);\n  this.development(false);\n  this.sourceMap(false);\n  this.concurrency(50);\n  this.update(false);\n  this.cache(true);\n\n  this.assets = [];\n  this.mapping = {};\n  this.includes = {};\n  this.packages = {};\n  this.json = readJson(this.path('component.json'));\n\n  // plugins\n  this.plugins = new Ware();\n  this.plugins.run = thunk(this.plugins.run);\n\n  // alternate plugins (used for the full build, not individual files)\n  this.altPlugins = new Ware();\n  this.altPlugins.run = thunk(this.altPlugins.run);\n}\n\n/**\n * Inherit from `Emitter`.\n */\n\nutil.inherits(Duo, Emitter);\n\n/**\n * Get or set the entry file for the package.\n *\n * You can either specify a single `path` to an entry file:\n *\n *   duo.entry('index.js');\n *\n * Or you can pass a source string and a file type:\n *\n *   duo.entry('var a = 0;', 'js');\n *\n * @param {String} path or source (optional)\n * @param {String} type (optional)\n * @return {Duo|File}\n * @api public\n */\n\nDuo.prototype.entry = function () {\n  switch (arguments.length) {\n    case 0:\n      return this._entry;\n    case 1:\n      this._entry = this.file({\n        path: arguments[0],\n        entry: true\n      });\n      return this;\n    case 2:\n      this._entry = this.file({\n        raw: arguments[0],\n        type: arguments[1],\n        entry: true\n      });\n      return this;\n  }\n};\n\n/**\n * Get or set the root `dir` for the package.\n *\n * @param {String} dir (optional)\n * @return {Duo|String}\n * @api public\n */\n\nDuo.prototype.root = function (dir) {\n  if (!arguments.length) return this._root;\n  this._root = dir;\n  return this;\n};\n\n/**\n * Get or set the `token` to authenticate to GitHub with.\n *\n * @param {String} token (optional)\n * @return {Duo|String}\n * @api public\n */\n\nDuo.prototype.token = function (token) {\n  if (!arguments.length) return this._token;\n  this._token = token;\n  return this;\n};\n\n/**\n * Get or set the manifest `name` to read settings from.\n *\n * @param {String} name\n * @return {Duo|String}\n * @api public\n */\n\nDuo.prototype.manifest = function (name) {\n  if (!arguments.length) return this._manifest;\n  this._manifest = name;\n  return this;\n};\n\n/**\n * Get or set a global variable `name` to expose the entry file by.\n *\n * @param {String} name (optional)\n * @return {String|Duo}\n * @api public\n */\n\nDuo.prototype.global = function (name) {\n  if (!arguments.length) return this._global;\n  this._global = name;\n  return this;\n};\n\n/**\n * Get or set standalone `name`, this will be used\n * to create a standalone JS (umd).\n *\n * @param {String} name\n * @return {String|Duo}\n * @api public\n */\n\nDuo.prototype.standalone = function (name) {\n  if (!arguments.length) return this.umd;\n  this.umd = name;\n  return this;\n};\n\n/**\n * Get or set whether to install development dependencies.\n *\n * @param {Boolean} value (optional)\n * @return {Duo|Boolean}\n * @api public\n */\n\nDuo.prototype.development = function (value) {\n  if (!arguments.length) return this._development;\n  this._development = value;\n  return this;\n};\n\n/**\n * Get or set whether to include source-maps.\n *\n * @param {Boolean|String}  true, false or 'inline'\n * @return {Duo|Boolean|String}\n * @api public\n */\n\nDuo.prototype.sourceMap = function (value) {\n  if (!arguments.length) return this._sourceMap;\n  this._sourceMap = value;\n  return this;\n};\n\n/**\n * Get or set whether to copy built files instead of symlinking them.\n *\n * @param {Boolean} value (optional)\n * @return {Duo|Boolean}\n * @api public\n */\n\nDuo.prototype.copy = function (value) {\n  if (!arguments.length) return this._copy;\n  this._copy = value;\n  return this;\n};\n\n/**\n * Get or set the download concurrency `value`.\n *\n * @param {Number} value (optional)\n * @return {Duo|Number}\n * @api public\n */\n\nDuo.prototype.concurrency = function (value) {\n  if (!arguments.length) return this._concurrency;\n  this._concurrency = value;\n  return this;\n};\n\n/**\n * Get or set the flag determining if we should always resolve dependencies.\n * (rather than relying on cache)\n *\n * @param {Boolean} value (optional)\n * @return {Duo|Boolean}\n * @api public\n */\n\nDuo.prototype.update = function (value) {\n  if (!arguments.length) return this._update;\n  this._update = value;\n  return this;\n};\n\n/**\n * Get or set whether the cache should be used.\n *\n * @param {Boolean} value (optional)\n * @return {Duo|Boolean}\n * @api public\n */\n\nDuo.prototype.cache = function (value) {\n  if (!arguments.length) return this._cache;\n  this._cache = value;\n  return this;\n};\n\n/**\n * Gets the cache object if this build is configured to use\n * caching.\n *\n * @return {Cache|Boolean}\n */\n\nDuo.prototype.getCache = unyield(function* () {\n  if (!this._cache) return false;\n\n  if (!this._cacheInstance) {\n    yield mkdir(this.installPath());\n    var inst = cache(this.installPath('duo-cache'));\n    yield inst.initialize();\n    this._cacheInstance = inst;\n  }\n\n  return this._cacheInstance;\n});\n\n/**\n * Get or set the `path` to install dependencies to.\n *\n * @param {String} path (optional)\n * @return {Duo|String}\n * @api public\n */\n\nDuo.prototype.installTo = function (path) {\n  if (!arguments.length) return this._installTo;\n  this._installTo = path;\n  return this;\n};\n\n/**\n * Get or set the `path` to build source to.\n *\n * @param {String} path (optional)\n * @return {Duo|String}\n * @api public\n */\n\nDuo.prototype.buildTo = function (path) {\n  if (!arguments.length) return this._buildTo;\n  this._buildTo = path;\n  return this;\n};\n\n/**\n * Use an async, sync or generator `plugin` function.\n *\n * @param {Function} plugin\n * @return {Duo}\n * @api public\n */\n\nDuo.prototype.use = function (fn) {\n  if (Array.isArray(fn)) {\n    fn.forEach(this.use, this);\n  } else {\n    if (fn.alternate) {\n      this.altPlugins.use(fn);\n    } else {\n      this.plugins.use(fn);\n    }\n\n    log.call(this, fn);\n  }\n\n  function log(fn) {\n    var name = fn.name || '(anonymous)';\n    this.emit('plugin', name);\n    debug('using plugin: %s', name);\n  }\n\n  return this;\n};\n\n/**\n * Resolve `paths...` relative to the root directories.\n *\n * @param {String} paths...\n * @return {String}\n * @api public\n */\n\nDuo.prototype.path = function () {\n  var strs = slice.call(arguments);\n  strs.unshift(this.root());\n  return path.join.apply(path, strs);\n};\n\n/**\n * Resolve `paths...` relative to the build directory.\n *\n * @param {String} paths...\n * @return {String}\n * @api public\n */\n\nDuo.prototype.buildPath = function () {\n  var strs = slice.call(arguments);\n  strs.unshift(this.buildTo());\n  return this.path.apply(this, strs);\n};\n\n/**\n * Resolve `paths...` relative to the install directory.\n *\n * @param {String} paths...\n * @return {String}\n * @api public\n */\n\nDuo.prototype.installPath = function () {\n  var strs = slice.call(arguments);\n  strs.unshift(this.installTo());\n  return this.path.apply(this, strs);\n};\n\n/**\n * Destroy the mapping. (the cache used here)\n */\n\nDuo.prototype.cleanCache = unyield(function* () {\n  debug('clearing cache');\n  var cache = yield this.getCache();\n  if (cache) yield cache.clean();\n});\n\n/**\n * Include a runtime by `name` and `src`.\n *\n * @param {String} name\n * @param {String} src\n * @return {Duo}\n * @api public\n */\n\nDuo.prototype.include = function (name, src, type) {\n  this.includes[name] = {\n    id: name,\n    src: src,\n    entry: false,\n    include: true,\n    deps: includeDeps(src, type)\n  };\n\n  return this;\n};\n\n/**\n * Check the includes hash for the given name\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nDuo.prototype.included = function (name) {\n  return name in this.includes;\n};\n\n/**\n * Write the built source to a `path`, which defaults\n * to the same name as the entry file's name.\n *\n * @param {String} path (optional)\n * @param {Function} fn (optional)\n * @return {Duo}\n * @api public\n */\n\nDuo.prototype.write = unyield(function* (path) {\n  var results = yield this.run();\n  var entry = this.entry();\n  var dir = this.buildPath();\n  var type = entry.type;\n  var rel = entry.id;\n\n  if (!supported(entry.type)) return this;\n\n  // resolve the path\n  path = resolve(dir, path || rel);\n\n  // change the extension if the type has changed\n  var base = basename(path, extname(path)) + '.' + type;\n  dir = dirname(path);\n\n  // update the path\n  path = join(dir, base);\n\n  // write the file\n  yield mkdir(dir);\n\n  if (results.code) {\n    yield fs.writeFile(path, results.code);\n    this.emit('write', base);\n  }\n\n  if (results.map) {\n    yield fs.writeFile(path + '.map', results.map);\n    this.emit('write', base + '.map');\n  }\n\n  return this;\n});\n\n/**\n * Processes the entry file and generates it's mapping,\n * by separating out this step, we can effectively implement\n * a `duo install` that will fetch dependencies.\n *\n * @returns {Object} deps mapping\n * @api public\n */\n\nDuo.prototype.install = unyield(function* () {\n  var entry = this.entry();\n  if (!entry) return {};\n\n  var rel = entry.id;\n  var global = this.global();\n\n  // logging\n  this.emit('running', rel);\n  debug('running: %s', rel);\n\n  // idempotent across runs\n  this.assets = [];\n\n  // add core plugins\n  this\n    .use(compat())\n    .use(stoj());\n\n  var cache = yield this.getCache();\n  if (cache) this.mapping = yield cache.read();\n\n  this.updateDeps = (yield this.isManifestModified()) || this.update();\n\n  // ensure that the entry exists\n  if (!(yield entry.exists())) {\n    throw error('cannot find entry: %s', rel);\n  }\n\n  // fetch the map of the dependency graph\n  var deps = yield this.dependencies(entry);\n\n  // add \"includes\" to dependency mapping\n  deps = extend(deps, this.includes);\n\n  // add global\n  if (global) deps[rel].global = global;\n\n  // write out the asset files in parallel\n  yield this.parallel(this.assets);\n\n  // write out mapping\n  if (cache) yield cache.update(deps);\n\n  // standalone?\n  if (this.standalone()) {\n    deps[rel].name = this.standalone();\n  }\n\n  return deps;\n});\n\n/**\n * Run duo on the entry file and return the built source.\n *\n * - Loads core duo plugins.\n * - Map out the dependency grpah.\n * - Add in the manually included files.\n * - Write the assets to the `buildTo()` path.\n * - Write out the map of the dependency graph to `components/duo.json`.\n * - Build the source by passing the `mapping` into duo-pack.\n *\n * @param {Function} fn (optional)\n * @return {String}\n * @api public\n */\n\nDuo.prototype.run = unyield(function* () {\n  var entry = this.entry();\n  if (!entry) return { code: '' }; // TODO: throw error instead?\n\n  var rel = entry.id;\n  var deps = yield this.install();\n\n  // pack the mapping\n  var pack = new Pack(deps, { umd: this.standalone() });\n  var map = this.sourceMap();\n  if (map) pack.sourceMap(map);\n  var results = pack.pack(rel);\n\n  // apply full build plugins\n  yield this.altPlugins.run(results, this.entry(), this);\n\n  // logging\n  this.emit('run', rel);\n  debug('ran: %s', rel);\n\n  return results;\n});\n\n/**\n * Recursively transform, parse and fetch the dependencies of `file`.\n * Returns a flat `map` of the full dependency graph.\n *\n * - `this.mapping` is a cache to only build files that have been changed.\n * - `map` is a current snapshot of the dependency graph.\n * - `map` gets built as we recurse.\n *\n * @param {File} file\n * @param {Object} map\n * @return {Object}\n * @api private\n */\n\nDuo.prototype.dependencies = function* (file, map) {\n  yield file.modified();\n\n  map = map || {};\n\n  var json = clone(this.mapping[file.id] || {});\n  var includes = this.includes;\n  var cache = this.cache();\n  var paths = [];\n  var gens = [];\n\n  // logging\n  debug('parsing: %s', file.id);\n\n  var isCached = file.mtime === json.mtime;\n  var isIncluded = json.include;\n  var isParsed = map[file.id];\n\n  // `file` already visited\n  if (isParsed) {\n    debug('%s, already parsed. ignoring', file.id);\n    return map;\n  }\n\n  // `file` included manually already\n  if (isIncluded) {\n    debug('%s, included manually. ignoring', file.id);\n    map[file.id] = json;\n    return map;\n  }\n\n  // check if the `file` has been modified\n  // if not, skip parsing and recurse its\n  // dependencies immediately.\n  if (cache && !this.updateDeps && isCached) {\n    debug('%s: has not been modified. skip parsing', file.id);\n    map[file.id] = json;\n    paths = values(json.deps);\n    gens = [];\n\n    // update the file with the cached\n    // dependency mapping\n    file.set(json);\n\n    // bundle if there is a non-supported file type\n    if (!supported(file.type)) this.assets.push(this.bundle(file.id));\n\n    // recurse the dependency's dependencies\n    gens = this.recurse(paths, map);\n    yield this.parallel(gens);\n    return map;\n  }\n\n  // load the file, applying plugin transforms\n  yield file.load();\n\n  // not a supported file type, don't parse any farther\n  // but include in duo.json, for symlinking or copying\n  if (!supported(file.type)) {\n    this.assets.push(this.bundle(file.id));\n    delete file.attrs.src;\n    map[file.id] = file.json();\n    return map;\n  }\n\n  // parse content for dependencies\n  var deps = file.dependencies();\n  var depmap = {};\n\n  // logging\n  debug('%s deps: %j', file.id, deps);\n\n  // download and resolve the dependencies\n  deps.forEach(function (dep) {\n    depmap[dep] = includes[dep]\n      ? dep\n      : this.dependency(dep, file, this.entry());\n  }, this);\n\n  // resolve dependencies from entry files,\n  // and remove unresolved deps\n  depmap = compact(yield depmap);\n  paths = values(depmap);\n\n  // update the file with the resolved dependencies\n  file.set({ deps: depmap });\n  map[file.id] = file.json();\n\n  // recurse the dependency's dependencies\n  gens = this.recurse(paths, map);\n  yield this.parallel(gens);\n  return map;\n};\n\n/**\n * Create generators to recurse the next layer\n * of dependencies in the dependency graph\n *\n * @param {Array} deps\n * @param {Object} map\n * @return {Array}\n * @api private\n */\n\nDuo.prototype.recurse = function (deps, map) {\n  var includes = this.includes;\n  var gens = [];\n\n  deps.forEach(function (dep) {\n    if (includes[dep]) return;\n\n    var dest = this.path(dep);\n    var root = this.findRoot(dest);\n    var local = dep.split(path.sep)[0] !== this.installTo();\n\n    var file = this.file({\n      root: root,\n      path: dest,\n      local: local\n    });\n\n    gens.push(this.dependencies(file, map));\n  }, this);\n\n  return gens;\n};\n\n/**\n * Resolve a single dependency's path. Supports local and remote dependencies.\n * Fetches remote packages to components/ to resolve remote paths.\n *\n * Examples:\n *\n *  1. this.dependency('./one.js', file, entry)\n *      => lib/one/one.js\n *\n *  2. this.dependency('component/tip', file, entry)\n *      => components/component-tip@master/index.js\n *\n *  3. this.dependency('yields/skeleton', file, entry)\n *      => components/yields-skeleton@master/skeleton.css\n *\n *  Where:\n *\n *    `file` is the current file with the dependency `dep`.\n *    `entry` is the root file you passed into Duo.\n *\n * @param {String} dep\n * @param {File} file\n * @param {File} entry\n * @return {String|Boolean}\n * @api private\n */\n\nDuo.prototype.dependency = function* (dep, file, entry) {\n  // ignore http dependencies\n  if (http(dep)) {\n    debug('%s: ignoring dependency \"%s\"', file.id, dep);\n    return false;\n  }\n\n  // `dep` is a local dependency\n  var local = yield this.resolve(dep, file, this.entry());\n  if (local) {\n    debug('%s: local dependency \"%s\"', file.id, dep);\n    return relative(entry.root, local);\n  } else if (isLocal(dep)) {\n    debug('%s: local dependency \"%s\" not found', file.id, dep);\n    throw error('unable to resolve local dependency ' + dep + ' from ' + file.id);\n  }\n\n  // `dep` is a remote dependency\n  var pkg = this.package(dep, file);\n  if (!pkg) {\n    debug('%s: cannot resolve \"%s\"', file.id, dep);\n    return false;\n  }\n\n  // add cache layer\n  var cache = yield this.getCache();\n  if (cache) pkg.cache(cache);\n\n  // install the dependency from github\n  // or another remote to 'components/'\n  yield pkg.fetch();\n\n  // resolve the remote dependency's path\n  var path = pkg.path(parse(dep).path || 'component.json');\n  var pkgfile = this.file({ root: pkg.path(), path: path });\n  var resolved = yield this.resolve(path, pkgfile, this.entry());\n\n  // logging\n  if (!resolved) debug('%s: cannot resolve \"%s\"', file.id, dep);\n\n  // return resolved or false\n  return resolved\n    ? relative(entry.root, resolved)\n    : false;\n};\n\n/**\n * Resolve the full local path of `dep`.\n *\n * TODO: clean & move this function into `duo-resolve`.\n *\n * Examples:\n *\n *   1. Local dependency:\n *\n *     this.resolve('./one.js', file, entry)\n *       => lib/one/one.js\n *\n *   2. Remote dependency (after it's installed):\n *\n *     this.resolve('$HOME/components/yields-skeleton@0.0.1/component.json', file, entry)\n *       => $HOME/components/yields-skeleton@0.0.1/skeleton.css\n *\n *  Where:\n *\n *    `file` is the current file with the dependency `dep`.\n *    `entry` is the root file you passed into Duo.\n *\n * @param {String} dep\n * @param {String} root\n * @return {String} path\n * @api private\n */\n\nDuo.prototype.resolve = function* (dep, file, entry) {\n  var isManifest = this.manifest() === basename(dep);\n  var type = entry.type;\n  var ext = extension(dep) === type ? '' : '.' + type;\n  var path = resolve(dirname(file.path), dep);\n  var isRelative = dep.slice(0, 2) === './';\n  var isParent = dep.slice(0, 2) === '..';\n  var isAbsolute = dep[0] === '/';\n  var ret;\n\n  if (isManifest) {\n    // `dep` is a component.json\n    var json = readJson(resolve(file.root, dep));\n    var entrypoint = main(json, entry.type) || 'index.' + entry.type;\n    ret = resolve(file.root, dirname(dep), entrypoint);\n  } else if (isAbsolute) {\n    // `dep` is an absolute path (relative to app or component root)\n    var relroot = this.findRoot(file.path);\n    ret = join(relroot, dep.replace(relroot, ''));\n  } else if (isParent) {\n    // `dep` is a parent path with \"..\"\n    ret = path;\n  } else if (isRelative) {\n    // `dep` is a relative path with \"./\"\n    ret = path;\n  } else if (yield isRelativeCSS(entry, path)) {\n    // Hack to support for CSS relative paths without \"./\"\n    // Example: body { background-image: url('image.jpg'); }\n    ret = path;\n  }\n\n  // Could not resolve\n  if (!ret) return;\n\n  // Strip any hashes, querystrings, etc from path.\n  // fonts/glyphicons-halflings-regular.eot?#iefix\n  ret = stripPath(ret);\n\n  // does one of these file paths exist?\n  //\n  // ./file.{{ext}}\n  // ./file/index.{{ext}}\n  return yield exists([\n    ret + ext,\n    join(ret, 'index' + ext),\n    ret\n  ]);\n\n  // check filesystem for relative asset\n  function* isRelativeCSS(entry, path) {\n    if (entry.type !== 'css') return false;\n    path = stripPath(path);\n    if (!extension(path)) return false;\n    return yield exists(path);\n  }\n};\n\n/**\n * Helper to create a file with `attrs`.\n *\n * @param {Object} attrs\n * @return {File}\n * @api private\n */\n\nDuo.prototype.file = function (attrs) {\n  attrs.root = attrs.root || this.root();\n  return new File(attrs, this);\n};\n\n/**\n * Helper to create a package from a `dep` with `file`.\n *\n * - Finds the necessary information to fetch `dep`\n * - Adds in our github token\n * - Sets up the events\n *\n * Examples:\n *\n *   1. \"component/emitter\": \"0.1.0\" in our manifest\n *\n *     var pkg = this.package('emitter', file);\n *     pkg.slug(); => component/emitter@0.1.0\n *\n *   2. require('component/emitter@master:index.js')\n *\n *     var pkg = this.package('component/emitter@master:index.js');\n *     pkg.slug(); => component/emitter@master\n *\n *\n * @param {String} dep\n * @param {File} file\n * @return {Package|null}\n * @api private\n */\n\nDuo.prototype.package = function (dep, file) {\n  var manifest = readJson(join(file.root, this.manifest()));\n  var gh = this.findDependency(dep, manifest);\n  if (!gh) return null;\n\n  var token = this.token();\n\n  // check if this package is already in flight\n  var slug = [ gh.package, gh.ref ].join('@');\n  if (slug in this.packages) return this.packages[slug];\n\n  // initialize the package\n  var pkg = this.packages[slug] = new Package(gh.package, gh.ref);\n  pkg.directory(this.installPath());\n  if (token) pkg.token(token);\n\n  // forward package events to duo\n  pkg\n    .once('resolving', this.forward('resolving'))\n    .once('installing', this.forward('installing'))\n    .once('resolve', this.forward('resolve'))\n    .once('install', this.forward('install'));\n\n  return pkg;\n};\n\n/**\n * Piece together the remote repository information from the dependency `dep`.\n *\n * - Consults the manifest for additional information, when needed.\n * - Includes development dependencies in when `development()` is set\n *\n * Examples:\n *\n *   1. specific dependency. no `manifest`:\n *\n *     this.findDependency('component/emitter', {})\n *     => {\n *          package: 'component/emitter',\n *          user: 'component',\n *          repo: 'emitter',\n *          ref: '*'\n *        }\n *\n *   2. vague dependency. \"component/emitter\": \"0.1.0\" is in the `manifest`:\n *\n *     this.findDependency('emitter', manifest)\n *     => {\n *          package: 'component/emitter',\n *          user: 'component',\n *          repo: 'emitter',\n *          ref:  '0.1.0'\n *        }\n *\n *   3. specific dependency. \"component/emitter\": \"0.1.0\" is in the `manifest`:\n *\n *     this.findDependency('component/emitter@1.0.0', manifest)\n *     => {\n *          package: 'component/emitter',\n *          user: 'component',\n *          repo: 'emitter'\n *          ref: '0.1.0'\n *        }\n *\n * @param {String} dep\n * @param {Object} manifest\n * @return {Object}\n * @api private\n */\n\nDuo.prototype.findDependency = function (dep, manifest) {\n  var gh = parse(dep);\n\n  // We have all the information we need from `dep`.\n  // Set the `package` key and return.\n  if (gh.user && gh.repo && gh.ref) {\n    gh.package = gh.user + '/' + gh.repo;\n    return gh;\n  }\n\n  var dev = this.development();\n  var deps = manifest.dependencies || {};\n  var rext = /([\\.][a-z]+)?/;\n\n  // Include development dependencies if `development(true)` is set.\n  if (dev && manifest === this.json) {\n    deps = extend(deps, manifest.development || {});\n  }\n\n  // Build a regexp based on if we have the `user` key or not.\n  // If we have the `user` key, our search is more specific.\n  var re = gh.user\n    ? new RegExp('^' + gh.user + '[\\\\/:]' + gh.repo + rext.source + '$', 'i')\n    : new RegExp('([\\\\/:])' + gh.repo + rext.source + '$', 'i');\n\n  // Not enough information yet.\n  // Search through the manifest for our dependency.\n  for (dep in deps) {\n    if (re.test(dep) || dep.replace('/', '-') === gh.repo) {\n      gh.package = dep;\n      gh.ref = deps[dep];\n      return gh;\n    }\n  }\n\n  // We have the `user` and `repo` keys, but not the `ref`.\n  // Although vague, we have enough information to find our dependency.\n  // Set `ref` to `*` and add in our `package` key.\n  if (gh.user && gh.repo) {\n    gh.package = gh.user + '/' + gh.repo;\n    gh.ref = '*';\n    return gh;\n  }\n\n  // Not enough information to find the dependency.\n  return null;\n};\n\n/**\n * Given a `path`, find the root.\n * TODO: fix this for windows.\n *\n * - `root` is relative. It could be the project `root` or a component's `root`\n *\n * Examples:\n *\n *   1. Project root (app):\n *\n *     this.findRoot('$HOME/app/lib/one/one.js')\n *     => $HOME/app\n *\n *   2. Component root\n *\n *     this.findRoot('$HOME/app/components/component-reactive@1.2.0/lib/index.js')\n *     => $HOME/app/components/component-reactive@1.2.0\n *\n * @param {String} path\n * @return {String} root\n * @api private\n */\n\nDuo.prototype.findRoot = function (path) {\n  var root = this.root();\n\n  while (path !== '.' && path !== root && !isSlug(basename(path))) {\n    path = dirname(path);\n  }\n\n  if (path === '.') {\n    throw error('could not find root for %s', path);\n  }\n\n  return path;\n};\n\n/**\n * Copy over assets from a `path` relative to the assets path.\n * This will symlink unless `duo.copy(true)` has been set.\n *\n * @param {String} path\n * @return {Duo}\n */\n\nDuo.prototype.bundle = function* (path) {\n  var log = this.copy() ? 'copying' : 'symlinking';\n  var action = this.copy() ? cp : fs.symlink;\n  var dest = this.buildPath(path);\n  var rm = fs.unlink;\n\n  // mkdir -p\n  yield mkdir(dirname(dest));\n\n  // fullpath\n  path = this.path(path);\n\n  // try removing any existing symlink or file first\n  try {\n    yield rm(dest);\n  } catch(e) {\n    if (e.code !== 'ENOENT') throw e;\n  }\n\n  // symlink or copy the file\n  debug('%s: %s => %s', log, path, dest);\n  try {\n    yield action(path, dest);\n  } catch(e) {\n    if (e.code !== 'EEXIST') throw e;\n    else debug('caught: %s already exists', dest);\n  }\n\n  return this;\n};\n\n/**\n * Forward events with a `name`, adding the Duo instance as the final argument.\n *\n * @param {String} event\n * @return {Function}\n * @api private\n */\n\nDuo.prototype.forward = function (name) {\n  var duo = this;\n  return function () {\n    var args = slice.call(arguments);\n    var ctx = this;\n    args = [name].concat(args).concat(ctx);\n    duo.emit.apply(duo, args);\n    return ctx;\n  };\n};\n\n/**\n * Parallelize an array of generators with `concurrency`.\n *\n * @param {Array} arr\n * @return {Array}\n * @api private\n */\n\nDuo.prototype.parallel = function (arr) {\n  return parallel(arr, this.concurrency());\n};\n\n/**\n * Helper for hashing arbitrary input. (useful during caching,\n * particularly for plugins)\n *\n * Objects will be serialized into a JSON string. Then the `input`\n * string will be hashed using MD5.\n *\n * @param {Mixed} input\n * @return {String} hash\n */\n\nDuo.prototype.hash = function (input) {\n  if (typeof input !== 'string' && !Buffer.isBuffer(input)) {\n    input = JSON.stringify(input);\n  }\n\n  return hasha(input, { algorithm: 'md5' });\n};\n\n/**\n * Check to see if the root manifest file has been modified.\n *\n * @return {Boolean}\n */\n\nDuo.prototype.isManifestModified = function* () {\n  // the path to check\n  var manifest = this.path(this.manifest());\n\n  // check if we even have this manifest, bail if we don't\n  var exists = yield fs.exists(manifest);\n  if (!exists) return false;\n\n  // try to get cache, bail if not in use\n  var cache = yield this.getCache();\n  if (!cache) return false;\n\n  // stat the current manifest\n  var current = yield fs.stat(manifest);\n  var value = current.mtime.getTime();\n  debug('current mtime for manifest %d', value);\n\n  // retrieve what we've stored in the cache previously\n  // update the cache with our new value regardless\n  var key = [ 'manifest', 'modified' ];\n  var previous = yield cache.get(key);\n  if (previous) debug('previous mtime for manifest: %d', previous);\n  yield cache.put(key, value);\n\n  // if no previous value, assume yes\n  var ret = !previous || previous !== value;\n  debug('manifest modified? %j', ret);\n  if (ret) {\n    // reset the manifest data internally if we determine it has been modified\n    delete require.cache[manifest]; // FIXME! this is an internal API\n    this.json = readJson(manifest);\n  }\n  return ret;\n};\n\n/**\n * Get the extension of a `path`, without the leading period.\n *\n * @param {String} path\n * @return {String} ext\n * @api private\n */\n\nfunction extension(path) {\n  return extname(path).slice(1);\n}\n\n/**\n * Convenience to turn a `msg` with placeholders into a proper `Error`.\n *\n * @param {String} msg\n * @return {Error}\n * @api private\n */\n\nfunction error(msg) {\n  var args = slice.call(arguments, 1);\n  msg = fmt.apply(fmt, [msg].concat(args));\n  return new Error(msg);\n}\n\n/**\n * Is the extension supported by Duo?\n *\n * @param {String} ext\n * @return {Boolean}\n * @api private\n */\n\nfunction supported(ext) {\n  return /^(js|css)$/.test(ext);\n}\n\n/**\n * Strip a querystring or hash fragment from a `path`.\n *\n * @param {String} path\n * @return {String}\n * @api private\n */\n\nfunction stripPath(path) {\n  return path\n    .split('?')[0]\n    .split('#')[0];\n}\n\n/**\n * Check if `url` is an HTTP URL.\n *\n * @param {String} path\n * @param {Boolean}\n * @api private\n */\n\nfunction http(url) {\n  return url.slice(0, 4) === 'http'\n    || url.slice(0, 3) === '://'\n    || false;\n}\n\n/**\n * Get the values of an `obj`.\n *\n * @param {Object} obj\n * @return {Array}\n * @api private\n */\n\nfunction values(obj) {\n  if (!obj) return [];\n  return Object.keys(obj).map(function (k) {\n    return obj[k];\n  });\n}\n\n/**\n * Remove empty values from an `obj`.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction compact(obj) {\n  var out = {};\n\n  for (var k in obj) {\n    if (obj[k]) out[k] = obj[k];\n  }\n\n  return out;\n}\n\n/**\n * Safely read a JSON file by `path`, with caching.\n *\n * @param {String} path\n * @return {Object}\n * @api private\n */\n\nfunction readJson(path) {\n  try {\n    return require(path);\n  } catch(e) {\n    if (e instanceof SyntaxError) throw jsonSyntaxError(e, path);\n    return {};\n  }\n}\n\n/**\n* Processes a SyntaxError trapped by readJson and creates a more user-friendly\n* error message. (and adds the `fileName` property)\n*\n* @param {SyntaxError} err\n* @returns {SyntaxError}\n*/\n\nfunction jsonSyntaxError(err, path) {\n  var msg = err.message.split(': ')[1];\n\n  err.message = msg;\n  err.fileName = path;\n\n  return err;\n}\n\n\n/**\n * Reads an include file and parses for dependencies\n *\n * TODO: Currently, an included file can **only** include other included files.\n *       This is a lame limitation, so it should be addressed in the future.\n *\n * @param {String} src\n * @param {String} type\n * @returns {Object}\n */\n\nfunction includeDeps(src, type) {\n  if (!type) return {};\n  return filedeps(src, type).reduce(function (acc, dep) {\n    acc[dep] = dep;\n    return acc;\n  }, {});\n}\n\n/**\n * Parses a path string to see if it is a dependency slug (where a slug is the\n * dirname for an installed dependency)\n *\n * @param {String} str\n * @returns {Boolean}\n */\n\nfunction isSlug(str) {\n  var repo = /([A-Za-z0-9-_\\.]+)/;\n  var user = /([A-Za-z0-9-]{1,39})/;\n  var ref = /([A-Za-z0-9-_\\/\\.$!#%&\\(\\)\\+=\\*]+)/;\n  var r = new RegExp(user.source + '-' + repo.source + '@' + ref.source, 'i');\n\n  return r.test(str);\n}\n\n/**\n * Tells us whether or not the input path is a local path. (begins with . or /)\n *\n * @param {String} path\n * @return {Boolean}\n */\nfunction isLocal(path) {\n  return path[0] === '.' || path[0] === '/';\n}\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-string-to-js/index.js":"/**\n * Module Dependencies\n */\n\nvar strtojs = require('string-to-js');\n\n/**\n * Export `string-to-js`\n */\n\nmodule.exports = plugin;\n\n/**\n * Initialize `plugin`\n *\n * @param {Object} file\n * @param {Object} entry\n */\n\nfunction plugin() {\n  return function stoj(file, entry) {\n    if (entry.type !== 'js') return;\n    if (file.type === 'js') return;\n\n    file.src = file.type === 'json'\n      ? 'module.exports = ' + file.src + ';'\n      : strtojs(file.src);\n    file.type = 'js';\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-css-compat/index.js":"/**\n * Module Dependencies\n */\n\nvar debug = require('debug')('duo-css-compat');\nvar Package = require('duo-package');\nvar fmt = require('util').format;\nvar join = require('path').join;\nvar main = require('duo-main');\nvar fs = require('co-fs');\nvar keys = Object.keys;\n\n/**\n * Export `plugin`\n */\n\nmodule.exports = plugin;\n\n/**\n * Add \"styles\" compatibility\n *\n * @param {Object} opts\n * @return {Function}\n * @api public\n */\n\nfunction plugin() {\n  var visited = {};\n\n  return function *compatibility(file, entry) {\n    if (file.type !== 'css' || entry.type !== 'css') return;\n\n    var duo = file.duo;\n    var token = duo.token();\n    var cache = yield duo.getCache();\n    var manifest = join(file.root, 'component.json');\n\n    // only visit a manifest once\n    if (visited[manifest]) return;\n    visited[manifest] = true;\n\n    var obj = json(manifest);\n    var styles = obj.styles;\n    var deps = obj.dependencies || {};\n\n    // only trigger for \"old\" components\n    // that have a \"styles\" attribute in\n    // their component.json\n    if (!styles || !styles.length) return;\n\n    // This will get picked up already in duo\n    if (styles.length === 1 && !keys(deps)) return;\n\n    // styles: [ ... ]\n    var entrypoint = main(obj, 'css');\n    var i = styles.indexOf(entrypoint);\n    if (~i) styles.splice(i, 1);\n\n    // Add the additional styles in, if there are any\n    styles.forEach(function (style) {\n      debug('%s: adding \"%s\" style', file.id, style);\n      file.src = fmt('%s\\n@import \"/%s\";', file.src, style);\n    });\n\n    // No need to continue if we don't have\n    // any additional dependencies\n    if (!keys(deps)) return;\n\n    var dir = join(entry.root, 'components');\n    var pkgs = [];\n\n    // dependencies: { ... }\n    // create packages for each dependency\n    for (var pkg in deps) {\n      pkgs[pkgs.length] = new Package(pkg, deps[pkg])\n        .cache(cache)\n        .token(token)\n        .directory(dir);\n    }\n\n    // fetch the packages\n    yield fetch(file.id, pkgs);\n\n    // filter out non-CSS packages\n    var paths = yield filter(pkgs);\n\n    // Add imports\n    paths.forEach(function (path) {\n      debug('%s: adding \"%s\" dependency', file.id, path);\n      file.src = fmt('@import \"%s\";\\n%s', path, file.src);\n    });\n  };\n}\n\n/**\n * Fetch the package\n *\n * @param {String} rel\n * @param {Array} pkgs\n * @return {Array}\n * @api private\n */\n\nfunction fetch(rel, pkgs) {\n  return pkgs.map(function(pkg) {\n    debug('%s: fetching \"%s\"', rel, pkg.slug());\n    return pkg.fetch();\n  });\n}\n\n/**\n * Filter out non-css packages\n *\n * @param {Package} pkg\n * @return {String}\n * @api private\n */\n\nfunction *filter(pkgs) {\n  var slugs = {};\n\n  // get the css path\n  var paths = pkgs\n    .map(function(pkg) {\n      var obj = json(pkg.path('component.json'));\n      var entry = main(obj, 'css') || 'index.css';\n      var path = pkg.path(main(obj, 'css') || 'index.css');\n      slugs[path] = fmt('%s:%s', pkg.slug(), entry);\n      return stat(path);\n    });\n\n  // check existence in parallel\n  paths = yield paths;\n\n  // filter out non-css packages\n  // and remap to slug:entry\n  return paths\n    .filter(function(path) {\n      return path;\n    })\n    .map(function(path) {\n      path = slugs[path];\n      return path;\n    });\n}\n\n/**\n * Load JSON\n *\n * @param {String} path\n * @return {Object}\n * @api private\n */\n\nfunction json(path) {\n  try {\n    return JSON.parse(JSON.stringify(require(path)));\n  } catch (e) {\n    return {};\n  }\n}\n\n/**\n * Stat\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nfunction *stat(path) {\n  try {\n    yield fs.stat(path);\n    return path;\n  } catch (e) {\n    return false;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-package/lib/index.js":"\n/**\n * Module dependencies\n */\n\nvar Emitter = require('events').EventEmitter;\nvar write = require('fs').createWriteStream;\nvar debug = require('debug')('duo-package');\nvar read = require('fs').createReadStream;\nvar resolve = require('gh-resolve');\nvar mkdir = require('mkdirp').sync;\nvar fmt = require('util').format;\nvar enstore = require('enstore');\nvar tmp = require('os').tmpdir();\nvar unyield = require('unyield');\nvar rm = require('rimraf-then');\nvar join = require('path').join;\nvar tar = require('tar-fs');\nvar zlib = require('zlib');\nvar util = require('util');\nvar fs = require('co-fs');\n\n/**\n * Export `Package`\n */\n\nmodule.exports = Package;\n\n/**\n * Inflight\n */\n\nvar inflight = {};\n\n/**\n * Cache tarballs in \"$tmp/duo\"\n * and make sure it exists\n */\n\nvar cachepath = join(tmp, 'duo');\nmkdir(cachepath);\n\n/**\n * Unauthorized string\n */\n\nvar unauthorized = 'You have not authenticated and this repo may be private.'\n  + ' Make sure you have a ~/.netrc entry or specify $GH_TOKEN=<token>.';\n\n/**\n * Initialize `Package`\n *\n * @param {String} repo\n * @param {String} ref\n * @api public\n */\n\nfunction Package(repo, ref) {\n  if (!(this instanceof Package)) return new Package(repo, ref);\n\n  this.repo = repo.replace(':', '/');\n  this.tok = null;\n  this.setMaxListeners(Infinity);\n  this.dir = process.cwd();\n  this.ua = 'duo-package';\n  this.resolved = false;\n  this.ref = ref || '*';\n  this.retries = 3;\n  Emitter.call(this);\n}\n\n/**\n * Inherit `EventEmitter`\n */\n\nutil.inherits(Package, Emitter);\n\n/**\n * Static property for accessing the cache location.\n */\n\nPackage.cachepath = cachepath;\n\n/**\n * Static method for cleaning the cache.\n */\n\nPackage.cleanCache = function *() {\n  yield rm(cachepath);\n};\n\n/**\n * Set the directory to install into\n *\n * @param {String} dir\n * @return {Package} self\n * @api public\n */\n\nPackage.prototype.directory = function(dir) {\n  if (!dir) return this.dir;\n  this.dir = dir;\n  return this;\n};\n\n/**\n * Get the local directory path\n *\n * @return {String}\n * @api public\n */\n\nPackage.prototype.path = function(path) {\n  return join(this.dir, this.slug(), path || '');\n};\n\n/**\n * Get or set the User-Agent\n *\n * @param {String} ua (optional)\n * @return {Package|String}\n */\n\nPackage.prototype.useragent = function(ua) {\n  if (!ua) return this.ua;\n  this.ua = ua;\n  return this;\n};\n\n/**\n * Authenticate with github\n *\n * @param {String} token\n * @return {String|Package} self\n * @api public\n */\n\nPackage.prototype.token = function(token) {\n  if (!arguments.length) return this.tok;\n  this.tok = token;\n  return this;\n};\n\n/**\n * Set the cache instance to use.\n *\n * @param {Cache} cache\n * @return {Cache|Package}\n * @api public\n */\n\nPackage.prototype.cache = function (cache) {\n  if (!arguments.length) return this._cache;\n  this._cache = cache;\n  return this;\n};\n\n/**\n * Resolve the reference on github\n *\n * @return {String}\n * @api public\n */\n\nPackage.prototype.resolve = unyield(function *() {\n  // resolved\n  if (this.resolved) {\n    this.debug('resolved from cache %s', this.resolved);\n    return this.resolved;\n  }\n\n  // FIXME: rewrite this, it's messy\n  if (this.resolving) {\n    this.debug('already being resolved, wait on result');\n    var self = this;\n    return yield function (done) {\n      self.on('resolve', function (ref) {\n        done(null, ref);\n      });\n    };\n  }\n\n  // resolving\n  this.resolving = true;\n  this.emit('resolving');\n  this.debug('resolving');\n\n  // resolve\n  var ref = yield resolve(this.repo + '@' + this.ref, {\n    token: this.token(),\n    cache: this.cache()\n  });\n\n  // resolved\n  this.resolving = false;\n  this.resolved = ref.name;\n  this.debug('resolved', ref.name);\n  this.emit('resolve', ref.name, this.repo);\n\n  return ref.name;\n});\n\n/**\n * Fetch the tarball from github\n * extracting to `dir`\n *\n * @return {Package} self\n * @api public\n */\n\nPackage.prototype.fetch = unyield(function *() {\n  // resolve\n  var ref = yield this.resolve();\n  var token = this.tok ? this.tok + '@' : '';\n  var url = fmt('https://%sgithub.com/%s/archive/%s.tar.gz', token, this.repo, ref);\n  var cache = join(cachepath, this.slug() + '.tar.gz');\n  var dest = this.path();\n\n  // inflight, wait till other package completes\n  if (inflight[dest]) {\n    var pkg = inflight[dest];\n    yield function(done){ pkg.once('fetch', done); };\n  }\n\n  // set package as inflight\n  inflight[dest] = this;\n\n  // check if directory already exists\n  if (yield this.exists()) {\n    // already exists\n    this.emit('fetching');\n    this.debug('already exists');\n    this.emit('fetch');\n    delete inflight[dest];\n\n    return this;\n  }\n\n  // check the cache\n  if (yield exists(cache)) {\n    // extracting\n    this.emit('fetching');\n    this.emit('installing');\n    this.debug('extracting from cache');\n\n    // extract\n    yield this.extract(cache, dest);\n\n    // extracted\n    this.emit('fetch');\n    this.emit('install');\n    this.debug('extracted from cache');\n    delete inflight[dest];\n\n    return this;\n  }\n\n  // fetching\n  this.emit('fetching');\n  this.emit('installing');\n  this.debug('fetching from %s', url);\n\n  // download tarball and extract\n  var store = yield this.download(url);\n\n  // cache, extract\n  yield [\n    this.write(store, cache),\n    this.extract(store, dest)\n  ];\n\n  // fetch\n  this.emit('fetch');\n  this.emit('install');\n  this.debug('fetched from %s', url);\n  delete inflight[dest];\n\n  return this;\n});\n\n/**\n * Check if the package exists.\n *\n * @return {Boolean}\n * @api private\n */\n\nPackage.prototype.exists = unyield(function*(){\n  return yield exists(this.path());\n});\n\n/**\n * Get the slug\n *\n * @return {String}\n * @api public\n */\n\nPackage.prototype.toString =\nPackage.prototype.slug = function() {\n  var repo = this.repo.replace('/', '-');\n  var ref = this.resolved || this.ref;\n  return repo + '@' + ref;\n};\n\n/**\n * Reliably download the package.\n * Returns a store to be piped around.\n *\n * @param {String} url\n * @return {Function}\n * @api private\n */\n\nPackage.prototype.download = function(url) {\n  var store = enstore();\n  var gzip = store.createWriteStream();\n  var opts = { headers: {} };\n  var tok = this.token();\n  var self = this;\n  var prev = 0;\n  var len = 0;\n\n  // options\n  opts.headers['User-Agent'] = this.ua;\n  opts.url = url;\n\n  return function(fn) {\n    var req = request(opts);\n    debug(curl(opts));\n\n    // handle any errors from the request\n    req.on('error', error);\n\n    store.on('end', function() {\n      return fn(null, store);\n    });\n\n    req.on('response', function(res) {\n      var status = res.statusCode;\n      var headers = res.headers;\n\n      // github doesn't always return a content-length (wtf?)\n      var total = +headers['content-length'];\n\n      // Ensure that we have the write status code\n      if (status < 200 || status >= 300) {\n        var statusError = status === 404 && !tok\n          ? self.error('returned with status code: %s. %s', status, unauthorized)\n          : self.error('returned with status code: %s', status);\n        return fn(statusError);\n      }\n\n      // listen for data and emit percentages\n      req.on('data', function(buf) {\n        len += buf.length;\n        var percent = Math.round(len / total * 100);\n        // TODO figure out what to do when no total\n        if (!total || prev >= percent) return;\n        self.debug('progress %s', percent);\n        self.emit('progress', percent);\n        prev = percent;\n      });\n\n      // pipe data into gunzip, then in-memory store\n      req.pipe(zlib.createGunzip())\n        .on('error', error)\n        .pipe(gzip);\n    });\n\n    function error(err) {\n      self.debug('error encountered: %s', err.message);\n      if (self.retries-- <= 0) { // after all retry attempts\n        fn(self.error(err));\n      } else {\n        self.debug('retry');\n        self.download(url);\n      }\n    }\n  };\n};\n\n/**\n * Extract the tarball\n *\n * @param {Enstore|String} store\n * @param {String} dest\n * @return {Function}\n * @api private\n */\n\nPackage.prototype.extract = function(store, dest) {\n  var self = this;\n\n  // create a stream\n  var stream = typeof store === 'string'\n    ? read(store)\n    : store.createReadStream();\n\n  return function(fn) {\n    stream\n      .on('error', error)\n      .pipe(tar.extract(dest, { strip: 1 }))\n      .on('error', error)\n      .on('finish', fn);\n\n    function error(err) {\n      return fn(self.error(err));\n    }\n  };\n};\n\n/**\n * Write the tarball\n *\n * @param {Enstore} store\n * @param {String} dest\n * @return {Function}\n * @api private\n */\n\nPackage.prototype.write = function(store, dest) {\n  var read = store.createReadStream();\n  var stream = write(dest);\n  var self = this;\n\n  return function(fn) {\n    read.pipe(stream)\n      .on('error', error)\n      .on('finish', fn);\n\n    function error(err) {\n      return fn(self.error(err));\n    }\n  };\n};\n\n/**\n * Debug\n *\n * @param {String} msg\n * @param {Mixed, ...} args\n * @return {Package}\n * @api private\n */\n\nPackage.prototype.debug = function(msg) {\n  var args = [].slice.call(arguments, 1);\n  msg = fmt('%s: %s', this.slug(), msg);\n  debug.apply(debug, [msg].concat(args));\n  return this;\n};\n\n/**\n * Error\n *\n * @param {String} msg\n * @return {Error}\n * @api private\n */\n\nPackage.prototype.error = function(msg) {\n  msg = fmt('%s: %s', this.slug(), msg.message || msg);\n  var args = [].slice.call(arguments, 1);\n  return new Error(fmt.apply(null, [msg].concat(args)));\n};\n\n/**\n * Display the curl request\n *\n * @param {Object} opts\n * @return {String}\n * @api private\n */\n\nfunction curl(opts) {\n  var arr = ['curl'];\n\n  // options\n  arr.push('-v');\n  arr.push('-L');\n\n  // headers\n  Object\n    .keys(opts.headers)\n    .forEach(function(header) {\n      arr.push(fmt('-H \"%s: %s\"', header, opts.headers[header]));\n    });\n\n  // url\n  arr.push(opts.url);\n\n  return arr.join(' ');\n}\n\n/**\n * Lazy-load request\n */\n\nfunction request() {\n  var req = require('request');\n  return req.apply(req, arguments);\n}\n\n/**\n * Exists\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nfunction *exists(path) {\n  try {\n    yield fs.stat(path);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-package/node_modules/tar-fs/index.js":"var tar = require('tar-stream');\nvar pump = require('pump');\nvar mkdirp = require('mkdirp');\nvar fs = require('fs');\nvar path = require('path');\nvar os = require('os');\n\nvar win32 = os.platform() === 'win32';\n\nvar noop = function() {};\n\nvar echo = function(name) {\n\treturn name;\n};\n\nvar normalize = !win32 ? echo : function(name) {\n\treturn name.replace(/\\\\/g, '/');\n};\n\nvar statAll = function(cwd, ignore) {\n\tvar queue = ['.'];\n\n\treturn function loop(callback) {\n\t\tif (!queue.length) return callback();\n\t\tvar next = queue.shift();\n\t\tvar nextAbs = path.join(cwd, next);\n\n\t\tfs.lstat(nextAbs, function(err, stat) {\n\t\t\tif (err) return callback(err);\n\n\t\t\tif (!stat.isDirectory()) return callback(null, next, stat);\n\n\t\t\tfs.readdir(nextAbs, function(err, files) {\n\t\t\t\tif (err) return callback(err);\n\n\t\t\t\tfor (var i = 0; i < files.length; i++) {\n\t\t\t\t\tif (!ignore(path.join(cwd, next, files[i]))) queue.push(path.join(next, files[i]));\n\t\t\t\t}\n\n\t\t\t\tcallback(null, next, stat);\n\t\t\t});\n\t\t});\n\t};\n};\n\nvar strip = function(map, level) {\n\treturn function(header) {\n\t\theader.name = header.name.split('/').slice(level).join('/')\n\t\tif (header.linkname) header.linkname = header.linkname.split('/').slice(level).join('/')\n\t\treturn map(header)\n\t}\n}\n\nexports.pack = function(cwd, opts) {\n\tif (!cwd) cwd = '.';\n\tif (!opts) opts = {};\n\n\tvar ignore = opts.ignore || noop;\n\tvar map = opts.map || noop;\n\tvar statNext = statAll(cwd, ignore);\n\tvar pack = tar.pack();\n\n\tif (opts.strip) map = strip(map, opts.strip)\n\n\tvar onlink = function(filename, header) {\n\t\tfs.readlink(path.join(cwd, filename), function(err, linkname) {\n\t\t\tif (err) return pack.destroy(err);\n\t\t\theader.linkname = normalize(linkname);\n\t\t\tpack.entry(header, onnextentry);\n\t\t});\n\t};\n\n\tvar onstat = function(err, filename, stat) {\n\t\tif (err) return pack.destroy(err);\n\t\tif (!filename) return pack.finalize();\n\n\t\tif (stat.isSocket()) return onnextentry() // tar does not support sockets...\n\n\t\tvar header = {\n\t\t\tname: normalize(filename),\n\t\t\tmode: stat.mode,\n\t\t\tmtime: stat.mtime,\n\t\t\tsize: stat.size,\n\t\t\ttype: 'file',\n\t\t\tuid: stat.uid,\n\t\t\tgid: stat.gid\n\t\t};\n\n\t\tif (stat.isDirectory()) {\n\t\t\theader.size = 0;\n\t\t\theader.type = 'directory';\n\t\t\treturn pack.entry(header, onnextentry);\n\t\t}\n\n\t\tif (stat.isSymbolicLink()) {\n\t\t\theader.size = 0;\n\t\t\theader.type = 'symlink';\n\t\t\treturn onlink(filename, header);\n\t\t}\n\n\t\t// TODO: add fifo etc...\n\n\t\tif (!stat.isFile()) return pack.destroy(new Error('unsupported type for '+filename));\n\n\t\theader = map(header) || header\n\n\t\tvar entry = pack.entry(header, onnextentry);\n\t\tif (!entry) return;\n\t\tvar rs = fs.createReadStream(path.join(cwd, filename));\n\n\t\tpump(rs, entry);\n\t};\n\n\tvar onnextentry = function(err) {\n\t\tif (err) return pack.destroy(err);\n\t\tstatNext(onstat);\n\t};\n\n\tonnextentry();\n\n\treturn pack;\n};\n\nvar head = function(list) {\n\treturn list.length ? list[list.length-1] : null\n};\n\nexports.extract = function(cwd, opts) {\n\tif (!cwd) cwd = '.';\n\tif (!opts) opts = {};\n\n\tvar ignore = opts.ignore || noop;\n\tvar map = opts.map || noop\n\tvar own = opts.chown !== false && !win32 && process.getuid() === 0;\n\tvar extract = tar.extract();\n\tvar stack = [];\n\tvar now = new Date();\n\tvar umask = typeof opts.umask === 'number' ? ~opts.umask : ~process.umask();\n\tvar dmode = typeof opts.dmode === 'number' ? opts.dmode : 0;\n\tvar fmode = typeof opts.fmode === 'number' ? opts.fmode : 0;\n\n\tif (opts.strip) map = strip(map, opts.strip)\n\n\tif (opts.readable) {\n\t\tdmode |= 0555;\n\t\tfmode |= 0444;\n\t}\n\tif (opts.writable) {\n\t\tdmode |= 0333;\n\t\tfmode |= 0222;\n\t}\n\n\tvar utimesParent = function(name, cb) { // we just set the mtime on the parent dir again everytime we write an entry\n\t\tvar top;\n\t\twhile ((top = head(stack)) && name.slice(0, top[0].length) !== top[0]) stack.pop();\n\t\tif (!top) return cb();\n\t\tfs.utimes(top[0], now, top[1], cb);\n\t};\n\n\tvar utimes = function(name, header, cb) {\n\t\tif (opts.utimes === false) return cb();\n\n\t\tif (header.type === 'directory') return fs.utimes(name, now, header.mtime, cb);\n\t\tif (header.type === 'symlink') return utimesParent(name, cb); // TODO: how to set mtime on link?\n\n\t\tfs.utimes(name, now, header.mtime, function(err) {\n\t\t\tif (err) return cb(err);\n\t\t\tutimesParent(name, cb);\n\t\t});\n\t};\n\n\tvar chperm = function(name, header, cb) {\n\t\tvar link = header.type === 'symlink';\n\t\tvar chmod = link ? fs.lchmod : fs.chmod;\n\t\tvar chown = link ? fs.lchown : fs.chown;\n\n\t\tif (!chmod) return cb();\n\t\tchmod(name, (header.mode | (header.type === 'directory' ? dmode : fmode)) & umask, function(err) {\n\t\t\tif (err) return cb(err);\n\t\t\tif (!own) return cb();\n\t\t\tif (!chown) return cb();\n\t\t\tchown(name, header.uid, header.gid, cb);\n\t\t});\n\t};\n\n\textract.on('entry', function(header, stream, next) {\n\t\theader = map(header) || header\n\t\tvar name = path.join(cwd, path.join('/', header.name));\n\n\t\tif (ignore(name)) {\n\t\t\tstream.resume();\n\t\t\treturn next();\n\t\t}\n\n\t\tvar stat = function(err) {\n\t\t\tif (err) return next(err);\n\t\t\tif (win32) return next();\n\t\t\tutimes(name, header, function(err) {\n\t\t\t\tif (err) return next(err);\n\t\t\t\tchperm(name, header, next);\n\t\t\t});\n\t\t};\n\n\t\tvar onlink = function() {\n\t\t\tif (win32) return next(); // skip symlinks on win for now before it can be tested\n\t\t\tfs.unlink(name, function() {\n\t\t\t\tfs.symlink(header.linkname, name, stat);\n\t\t\t});\n\t\t};\n\n\t\tvar onfile = function() {\n\t\t\tvar ws = fs.createWriteStream(name);\n\n\t\t\tpump(stream, ws, function(err) {\n\t\t\t\tif (err) return next(err);\n\t\t\t\tws.on('close', stat);\n\t\t\t});\n\t\t};\n\n\t\tif (header.type === 'directory') {\n\t\t\tstack.push([name, header.mtime]);\n\t\t\treturn mkdirp(name, stat);\n\t\t}\n\n\t\tmkdirp(path.dirname(name), function(err) {\n\t\t\tif (err) return next(err);\n\t\t\tif (header.type === 'symlink') return onlink();\n\t\t\tif (header.type !== 'file') return next(new Error('unsupported type for '+name+' ('+header.type+')'));\n\n\t\t\tonfile();\n\t\t});\n\t});\n\n\treturn extract;\n};\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-package/node_modules/tar-stream/index.js":"exports.extract = require('./extract')\nexports.pack = require('./pack')","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-package/node_modules/tar-stream/extract.js":"var util = require('util')\nvar bl = require('bl')\nvar xtend = require('xtend')\nvar headers = require('./headers')\n\nvar Writable = require('readable-stream').Writable\nvar PassThrough = require('readable-stream').PassThrough\n\nvar noop = function() {}\n\nvar overflow = function(size) {\n  size &= 511\n  return size && 512 - size\n}\n\nvar emptyStream = function() {\n  var s = new PassThrough()\n  s.end()\n  return s\n}\n\nvar mixinPax = function(header, pax) {\n  if (pax.path) header.name = pax.path\n  if (pax.linkpath) header.linkname = pax.linkpath\n  return header\n}\n\nvar Extract = function(opts) {\n  if (!(this instanceof Extract)) return new Extract(opts)\n  Writable.call(this, opts)\n\n  this._buffer = bl()\n  this._missing = 0\n  this._onparse = noop\n  this._header = null\n  this._stream = null\n  this._overflow = null\n  this._cb = null\n  this._locked = false\n  this._destroyed = false\n  this._pax = null\n  this._paxGlobal = null\n\n  var self = this\n  var b = self._buffer\n\n  var oncontinue = function() {\n    self._continue()\n  }\n\n  var onunlock = function(err) {\n    self._locked = false\n    if (err) return self.destroy(err)\n    if (!self._stream) oncontinue()\n  }\n\n  var onstreamend = function() {\n    self._stream = null\n    var drain = overflow(self._header.size)\n    if (drain) self._parse(drain, ondrain)\n    else self._parse(512, onheader)\n    if (!self._locked) oncontinue()\n  }\n\n  var ondrain = function() {\n    self._buffer.consume(overflow(self._header.size))\n    self._parse(512, onheader)\n    oncontinue()\n  }\n\n  var onpaxglobalheader = function() {\n    var size = self._header.size\n    self._paxGlobal = headers.decodePax(b.slice(0, size))\n    b.consume(size)\n    onstreamend()\n  }\n\n  var onpaxheader = function() {\n    var size = self._header.size\n    self._pax = headers.decodePax(b.slice(0, size))\n    if (self._paxGlobal) self._pax = xtend(self._paxGlobal, self._pax)\n    b.consume(size)\n    onstreamend()\n  }\n\n  var onheader = function() {\n    var header\n    try {\n      header = self._header = headers.decode(b.slice(0, 512))\n    } catch (err) {\n      self.emit('error', err)\n    }\n    b.consume(512)\n\n    if (!header) {\n      self._parse(512, onheader)\n      oncontinue()\n      return\n    }\n    if (header.type === 'pax-global-header') {\n      self._parse(header.size, onpaxglobalheader)\n      oncontinue()\n      return\n    }\n    if (header.type === 'pax-header') {\n      self._parse(header.size, onpaxheader)\n      oncontinue()\n      return\n    }\n\n    if (self._pax) {\n      self._header = header = mixinPax(header, self._pax)\n      self._pax = null\n    }\n\n    self._locked = true\n\n    if (!header.size) {\n      self._parse(512, onheader)\n      self.emit('entry', header, emptyStream(), onunlock)\n      return\n    }\n\n    self._stream = new PassThrough()\n\n    self.emit('entry', header, self._stream, onunlock)\n    self._parse(header.size, onstreamend)\n    oncontinue()\n  }\n\n  this._parse(512, onheader)\n}\n\nutil.inherits(Extract, Writable)\n\nExtract.prototype.destroy = function(err) {\n  if (this._destroyed) return\n  this._destroyed = true\n\n  if (err) this.emit('error', err)\n  this.emit('close')\n  if (this._stream) this._stream.emit('close')\n}\n\nExtract.prototype._parse = function(size, onparse) {\n  if (this._destroyed) return\n  this._missing = size\n  this._onparse = onparse\n}\n\nExtract.prototype._continue = function(err) {\n  if (this._destroyed) return\n  var cb = this._cb\n  this._cb = noop\n  if (this._overflow) this._write(this._overflow, undefined, cb)\n  else cb()\n}\n\nExtract.prototype._write = function(data, enc, cb) {\n  if (this._destroyed) return\n\n  var s = this._stream\n  var b = this._buffer\n  var missing = this._missing\n\n  // we do not reach end-of-chunk now. just forward it\n\n  if (data.length < missing) {\n    this._missing -= data.length\n    this._overflow = null\n    if (s) return s.write(data, cb)\n    b.append(data)\n    return cb()\n  }\n\n  // end-of-chunk. the parser should call cb.\n\n  this._cb = cb\n  this._missing = 0\n\n  var overflow = null\n  if (data.length > missing) {\n    overflow = data.slice(missing)\n    data = data.slice(0, missing)\n  }\n\n  if (s) s.end(data)\n  else b.append(data)\n\n  this._overflow = overflow\n  this._onparse()\n}\n\nmodule.exports = Extract\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-package/node_modules/bl/bl.js":"var DuplexStream = require('readable-stream/duplex')\n  , util         = require('util')\n\nfunction BufferList (callback) {\n  if (!(this instanceof BufferList))\n    return new BufferList(callback)\n\n  this._bufs  = []\n  this.length = 0\n\n  if (typeof callback == 'function') {\n    this._callback = callback\n\n    var piper = function (err) {\n      if (this._callback) {\n        this._callback(err)\n        this._callback = null\n      }\n    }.bind(this)\n\n    this.on('pipe', function (src) {\n      src.on('error', piper)\n    })\n    this.on('unpipe', function (src) {\n      src.removeListener('error', piper)\n    })\n  }\n  else if (Buffer.isBuffer(callback))\n    this.append(callback)\n  else if (Array.isArray(callback)) {\n    callback.forEach(function (b) {\n      Buffer.isBuffer(b) && this.append(b)\n    }.bind(this))\n  }\n\n  DuplexStream.call(this)\n}\n\nutil.inherits(BufferList, DuplexStream)\n\nBufferList.prototype._offset = function (offset) {\n  var tot = 0, i = 0, _t\n  for (; i < this._bufs.length; i++) {\n    _t = tot + this._bufs[i].length\n    if (offset < _t)\n      return [ i, offset - tot ]\n    tot = _t\n  }\n}\n\nBufferList.prototype.append = function (buf) {\n  var isBuffer = Buffer.isBuffer(buf) ||\n                 buf instanceof BufferList\n\n  // coerce number arguments to strings, since Buffer(number) does\n  // uninitialized memory allocation\n  if (typeof buf == 'number')\n    buf = buf.toString()\n\n  this._bufs.push(isBuffer ? buf : new Buffer(buf))\n  this.length += buf.length\n  return this\n}\n\nBufferList.prototype._write = function (buf, encoding, callback) {\n  this.append(buf)\n  if (callback)\n    callback()\n}\n\nBufferList.prototype._read = function (size) {\n  if (!this.length)\n    return this.push(null)\n  size = Math.min(size, this.length)\n  this.push(this.slice(0, size))\n  this.consume(size)\n}\n\nBufferList.prototype.end = function (chunk) {\n  DuplexStream.prototype.end.call(this, chunk)\n\n  if (this._callback) {\n    this._callback(null, this.slice())\n    this._callback = null\n  }\n}\n\nBufferList.prototype.get = function (index) {\n  return this.slice(index, index + 1)[0]\n}\n\nBufferList.prototype.slice = function (start, end) {\n  return this.copy(null, 0, start, end)\n}\n\nBufferList.prototype.copy = function (dst, dstStart, srcStart, srcEnd) {\n  if (typeof srcStart != 'number' || srcStart < 0)\n    srcStart = 0\n  if (typeof srcEnd != 'number' || srcEnd > this.length)\n    srcEnd = this.length\n  if (srcStart >= this.length)\n    return dst || new Buffer(0)\n  if (srcEnd <= 0)\n    return dst || new Buffer(0)\n\n  var copy   = !!dst\n    , off    = this._offset(srcStart)\n    , len    = srcEnd - srcStart\n    , bytes  = len\n    , bufoff = (copy && dstStart) || 0\n    , start  = off[1]\n    , l\n    , i\n\n  // copy/slice everything\n  if (srcStart === 0 && srcEnd == this.length) {\n    if (!copy) // slice, just return a full concat\n      return Buffer.concat(this._bufs)\n\n    // copy, need to copy individual buffers\n    for (i = 0; i < this._bufs.length; i++) {\n      this._bufs[i].copy(dst, bufoff)\n      bufoff += this._bufs[i].length\n    }\n\n    return dst\n  }\n\n  // easy, cheap case where it's a subset of one of the buffers\n  if (bytes <= this._bufs[off[0]].length - start) {\n    return copy\n      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)\n      : this._bufs[off[0]].slice(start, start + bytes)\n  }\n\n  if (!copy) // a slice, we need something to copy in to\n    dst = new Buffer(len)\n\n  for (i = off[0]; i < this._bufs.length; i++) {\n    l = this._bufs[i].length - start\n\n    if (bytes > l) {\n      this._bufs[i].copy(dst, bufoff, start)\n    } else {\n      this._bufs[i].copy(dst, bufoff, start, start + bytes)\n      break\n    }\n\n    bufoff += l\n    bytes -= l\n\n    if (start)\n      start = 0\n  }\n\n  return dst\n}\n\nBufferList.prototype.toString = function (encoding, start, end) {\n  return this.slice(start, end).toString(encoding)\n}\n\nBufferList.prototype.consume = function (bytes) {\n  while (this._bufs.length) {\n    if (bytes > this._bufs[0].length) {\n      bytes -= this._bufs[0].length\n      this.length -= this._bufs[0].length\n      this._bufs.shift()\n    } else {\n      this._bufs[0] = this._bufs[0].slice(bytes)\n      this.length -= bytes\n      break\n    }\n  }\n  return this\n}\n\nBufferList.prototype.duplicate = function () {\n  var i = 0\n    , copy = new BufferList()\n\n  for (; i < this._bufs.length; i++)\n    copy.append(this._bufs[i])\n\n  return copy\n}\n\nBufferList.prototype.destroy = function () {\n  this._bufs.length = 0;\n  this.length = 0;\n  this.push(null);\n}\n\n;(function () {\n  var methods = {\n      'readDoubleBE' : 8\n    , 'readDoubleLE' : 8\n    , 'readFloatBE'  : 4\n    , 'readFloatLE'  : 4\n    , 'readInt32BE'  : 4\n    , 'readInt32LE'  : 4\n    , 'readUInt32BE' : 4\n    , 'readUInt32LE' : 4\n    , 'readInt16BE'  : 2\n    , 'readInt16LE'  : 2\n    , 'readUInt16BE' : 2\n    , 'readUInt16LE' : 2\n    , 'readInt8'     : 1\n    , 'readUInt8'    : 1\n  }\n\n  for (var m in methods) {\n    (function (m) {\n      BufferList.prototype[m] = function (offset) {\n        return this.slice(offset, offset + methods[m])[m](0)\n      }\n    }(m))\n  }\n}())\n\nmodule.exports = BufferList\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-package/node_modules/bl/node_modules/readable-stream/duplex.js":"module.exports = require(\"./lib/_stream_duplex.js\")\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-package/node_modules/bl/node_modules/readable-stream/lib/_stream_duplex.js":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nforEach(objectKeys(Writable.prototype), function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-package/node_modules/bl/node_modules/readable-stream/lib/_stream_readable.js":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events').EventEmitter;\n\n/*<replacement>*/\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\nvar Stream = require('stream');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = false;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // In streams that never have any data, and do push(null) right away,\n  // the consumer can miss the 'end' event if they do some I/O before\n  // consuming the stream.  So, we don't emit('end') until some reading\n  // happens.\n  this.calledRead = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, becuase any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (typeof chunk === 'string' && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null || chunk === undefined) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      // update the buffer info.\n      state.length += state.objectMode ? 1 : chunk.length;\n      if (addToFront) {\n        state.buffer.unshift(chunk);\n      } else {\n        state.reading = false;\n        state.buffer.push(chunk);\n      }\n\n      if (state.needReadable)\n        emitReadable(stream);\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (n === null || isNaN(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  var state = this._readableState;\n  state.calledRead = true;\n  var nOrig = n;\n  var ret;\n\n  if (typeof n !== 'number' || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    ret = null;\n\n    // In cases where the decoder did not receive enough data\n    // to produce a full chunk, then immediately received an\n    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].\n    // howMuchToRead will see this and coerce the amount to\n    // read to zero (because it's looking at the length of the\n    // first <Buffer > in state.buffer), and we'll end up here.\n    //\n    // This can only happen via state.decoder -- no other venue\n    // exists for pushing a zero-length chunk into state.buffer\n    // and triggering this behavior. In this case, we return our\n    // remaining data and end the stream, if appropriate.\n    if (state.length > 0 && state.decoder) {\n      ret = fromList(n, state);\n      state.length -= ret.length;\n    }\n\n    if (state.length === 0)\n      endReadable(this);\n\n    return ret;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length - n <= state.highWaterMark)\n    doRead = true;\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading)\n    doRead = false;\n\n  if (doRead) {\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read called its callback synchronously, then `reading`\n  // will be false, and we need to re-evaluate how much data we\n  // can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we happened to read() exactly the remaining amount in the\n  // buffer, and the EOF has been seen at this point, then make sure\n  // that we emit 'end' on the very next tick.\n  if (state.ended && !state.endEmitted && state.length === 0)\n    endReadable(this);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!Buffer.isBuffer(chunk) &&\n      'string' !== typeof chunk &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // if we've ended and we have some data left, then emit\n  // 'readable' now to make sure it gets picked up.\n  if (state.length > 0)\n    emitReadable(stream);\n  else\n    endReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (state.emittedReadable)\n    return;\n\n  state.emittedReadable = true;\n  if (state.sync)\n    process.nextTick(function() {\n      emitReadable_(stream);\n    });\n  else\n    emitReadable_(stream);\n}\n\nfunction emitReadable_(stream) {\n  stream.emit('readable');\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    if (readable !== src) return;\n    cleanup();\n  }\n\n  function onend() {\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  function cleanup() {\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (!dest._writableState || dest._writableState.needDrain)\n      ondrain();\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    // the handler that waits for readable events after all\n    // the data gets sucked out in flow.\n    // This would be easier to follow with a .once() handler\n    // in flow(), but that is too slow.\n    this.on('readable', pipeOnReadable);\n\n    state.flowing = true;\n    process.nextTick(function() {\n      flow(src);\n    });\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var dest = this;\n    var state = src._readableState;\n    state.awaitDrain--;\n    if (state.awaitDrain === 0)\n      flow(src);\n  };\n}\n\nfunction flow(src) {\n  var state = src._readableState;\n  var chunk;\n  state.awaitDrain = 0;\n\n  function write(dest, i, list) {\n    var written = dest.write(chunk);\n    if (false === written) {\n      state.awaitDrain++;\n    }\n  }\n\n  while (state.pipesCount && null !== (chunk = src.read())) {\n\n    if (state.pipesCount === 1)\n      write(state.pipes, 0, null);\n    else\n      forEach(state.pipes, write);\n\n    src.emit('data', chunk);\n\n    // if anyone needs a drain, then we have to wait for that.\n    if (state.awaitDrain > 0)\n      return;\n  }\n\n  // if every destination was unpiped, either before entering this\n  // function, or in the while loop, then stop flowing.\n  //\n  // NB: This is a pretty rare edge case.\n  if (state.pipesCount === 0) {\n    state.flowing = false;\n\n    // if there were data event listeners added, then switch to old mode.\n    if (EE.listenerCount(src, 'data') > 0)\n      emitDataEvents(src);\n    return;\n  }\n\n  // at this point, no one needed a drain, so we just ran out of data\n  // on the next readable event, start it over again.\n  state.ranOut = true;\n}\n\nfunction pipeOnReadable() {\n  if (this._readableState.ranOut) {\n    this._readableState.ranOut = false;\n    flow(this);\n  }\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    this.removeListener('readable', pipeOnReadable);\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    this.removeListener('readable', pipeOnReadable);\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data' && !this._readableState.flowing)\n    emitDataEvents(this);\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        this.read(0);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  emitDataEvents(this);\n  this.read(0);\n  this.emit('resume');\n};\n\nReadable.prototype.pause = function() {\n  emitDataEvents(this, true);\n  this.emit('pause');\n};\n\nfunction emitDataEvents(stream, startPaused) {\n  var state = stream._readableState;\n\n  if (state.flowing) {\n    // https://github.com/isaacs/readable-stream/issues/16\n    throw new Error('Cannot switch to old mode now.');\n  }\n\n  var paused = startPaused || false;\n  var readable = false;\n\n  // convert to an old-style stream.\n  stream.readable = true;\n  stream.pipe = Stream.prototype.pipe;\n  stream.on = stream.addListener = Stream.prototype.on;\n\n  stream.on('readable', function() {\n    readable = true;\n\n    var c;\n    while (!paused && (null !== (c = stream.read())))\n      stream.emit('data', c);\n\n    if (c === null) {\n      readable = false;\n      stream._readableState.needReadable = true;\n    }\n  });\n\n  stream.pause = function() {\n    paused = true;\n    this.emit('pause');\n  };\n\n  stream.resume = function() {\n    paused = false;\n    if (readable)\n      process.nextTick(function() {\n        stream.emit('readable');\n      });\n    else\n      this.read(0);\n    this.emit('resume');\n  };\n\n  // now make it start, just in case it hadn't already.\n  stream.emit('readable');\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    //if (state.objectMode && util.isNullOrUndefined(chunk))\n    if (state.objectMode && (chunk === null || chunk === undefined))\n      return;\n    else if (!state.objectMode && (!chunk || !chunk.length))\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (typeof stream[i] === 'function' &&\n        typeof this[i] === 'undefined') {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted && state.calledRead) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    });\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-package/node_modules/bl/node_modules/readable-stream/lib/_stream_writable.js":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Stream = require('stream');\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, becuase any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!Buffer.isBuffer(chunk) &&\n      'string' !== typeof chunk &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function')\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb))\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n\n  return ret;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      cb(er);\n    });\n  else\n    cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished && !state.bufferProcessing && state.buffer.length)\n      clearBuffer(stream, state);\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  cb();\n  if (finished)\n    finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  for (var c = 0; c < state.buffer.length; c++) {\n    var entry = state.buffer[c];\n    var chunk = entry.chunk;\n    var encoding = entry.encoding;\n    var cb = entry.callback;\n    var len = state.objectMode ? 1 : chunk.length;\n\n    doWrite(stream, state, len, chunk, encoding, cb);\n\n    // if we didn't call the onwrite immediately, then\n    // it means that we need to wait until it does.\n    // also, that means that the chunk and cb are currently\n    // being processed, so move the buffer counter past them.\n    if (state.writing) {\n      c++;\n      break;\n    }\n  }\n\n  state.bufferProcessing = false;\n  if (c < state.buffer.length)\n    state.buffer = state.buffer.slice(c);\n  else\n    state.buffer.length = 0;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (typeof chunk !== 'undefined' && chunk !== null)\n    this.write(chunk, encoding);\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    state.finished = true;\n    stream.emit('finish');\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-package/node_modules/tar-stream/headers.js":"var ZEROS = '0000000000000000000'\nvar ZERO_OFFSET = '0'.charCodeAt(0)\nvar USTAR = 'ustar\\x0000'\n\nvar clamp = function(index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue\n  index = ~~index  // Coerce to integer.\n  if (index >= len) return len\n  if (index >= 0) return index\n  index += len\n  if (index >= 0) return index\n  return 0\n}\n\nvar toType = function(flag) {\n  switch (flag) {\n    case 0:\n    return 'file'\n    case 1:\n    return 'link'\n    case 2:\n    return 'symlink'\n    case 3:\n    return 'character-device'\n    case 4:\n    return 'block-device'\n    case 5:\n    return 'directory'\n    case 6:\n    return 'fifo'\n    case 7:\n    return 'contiguous-file'\n    case 72:\n    return 'pax-header'\n    case 55:\n    return 'pax-global-header'\n  }\n\n  return null\n}\n\nvar toTypeflag = function(flag) {\n  switch (flag) {\n    case 'file':\n    return 0\n    case 'link':\n    return 1\n    case 'symlink':\n    return 2\n    case 'character-device':\n    return 3\n    case 'block-device':\n    return 4\n    case 'directory':\n    return 5\n    case 'fifo':\n    return 6\n    case 'contiguous-file':\n    return 7\n    case 'pax-header':\n    return 72\n  }\n\n  return 0\n}\n\nvar alloc = function(size) {\n  var buf = new Buffer(size)\n  buf.fill(0)\n  return buf\n}\n\nvar indexOf = function(block, num, offset, end) {\n  for (; offset < end; offset++) {\n    if (block[offset] === num) return offset\n  }\n  return end\n}\n\nvar cksum = function(block) {\n  var sum = 8 * 32\n  for (var i = 0; i < 148; i++)   sum += block[i]\n  for (var i = 156; i < 512; i++) sum += block[i]\n  return sum\n}\n\nvar encodeOct = function(val, n) {\n  val = val.toString(8)\n  return ZEROS.slice(0, n-val.length)+val+' '\n}\n\nvar decodeOct = function(val, offset) {\n  // Older versions of tar can prefix with spaces\n  while (offset < val.length && val[offset] === 32) offset++\n\n  return parseInt(val.slice(offset, clamp(indexOf(val, 32, offset, val.length), val.length, val.length)).toString(), 8)\n}\n\nvar decodeStr = function(val, offset, length) {\n  return val.slice(offset, indexOf(val, 0, offset, offset+length)).toString();\n}\n\nvar addLength = function(str) {\n  var len = Buffer.byteLength(str)\n  var digits = Math.floor(Math.log(len) / Math.log(10)) + 1\n  if (len + digits > Math.pow(10, digits)) digits++\n\n  return (len+digits)+str\n}\n\nexports.encodePax = function(opts) { // TODO: encode more stuff in pax\n  var result = ''\n  if (opts.name) result += addLength(' path='+opts.name+'\\n')\n  if (opts.linkname) result += addLength(' linkpath='+opts.linkname+'\\n')\n  return new Buffer(result)\n}\n\nexports.decodePax = function(buf) {\n  var result = {}\n\n  while (buf.length) {\n    var i = 0\n    while (i < buf.length && buf[i] !== 32) i++\n\n    var len = parseInt(buf.slice(0, i).toString())\n    if (!len) return result\n\n    var b = buf.slice(i+1, len-1).toString()\n    var keyIndex = b.indexOf('=')\n    if (keyIndex === -1) return result\n    result[b.slice(0, keyIndex)] = b.slice(keyIndex+1)\n\n    buf = buf.slice(len)\n  }\n\n  return result\n}\n\nexports.encode = function(opts) {\n  var buf = alloc(512)\n  var name = opts.name\n  var prefix = ''\n\n  if (opts.typeflag === 5 && name[name.length-1] !== '/') name += '/'\n  if (Buffer.byteLength(name) !== name.length) return null // utf-8\n\n  while (Buffer.byteLength(name) > 100) {\n    var i = name.indexOf('/')\n    if (i === -1) return null\n    prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i)\n    name = name.slice(i+1)\n  }\n\n  if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155) return null\n  if (opts.linkname && Buffer.byteLength(opts.linkname) > 100) return null\n\n  buf.write(name)\n  buf.write(encodeOct(opts.mode & 07777, 6), 100)\n  buf.write(encodeOct(opts.uid, 6), 108)\n  buf.write(encodeOct(opts.gid, 6), 116)\n  buf.write(encodeOct(opts.size, 11), 124)\n  buf.write(encodeOct((opts.mtime.getTime() / 1000) | 0, 11), 136)\n\n  buf[156] = ZERO_OFFSET + toTypeflag(opts.type)\n\n  if (opts.linkname) buf.write(opts.linkname, 157)\n\n  buf.write(USTAR, 257)\n  if (opts.uname) buf.write(opts.uname, 265)\n  if (opts.gname) buf.write(opts.gname, 297)\n  buf.write(encodeOct(opts.devmajor || 0, 6), 329)\n  buf.write(encodeOct(opts.devminor || 0, 6), 337)\n\n  if (prefix) buf.write(prefix, 345)\n\n  buf.write(encodeOct(cksum(buf), 6), 148)\n\n  return buf\n}\n\nexports.decode = function(buf) {\n  var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET\n  var type = toType(typeflag)\n\n  var name = decodeStr(buf, 0, 100)\n  var mode = decodeOct(buf, 100)\n  var uid = decodeOct(buf, 108)\n  var gid = decodeOct(buf, 116)\n  var size = decodeOct(buf, 124)\n  var mtime = decodeOct(buf, 136)\n  var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100)\n  var uname = decodeStr(buf, 265, 32)\n  var gname = decodeStr(buf, 297, 32)\n  var devmajor = decodeOct(buf, 329)\n  var devminor = decodeOct(buf, 337)\n\n  if (buf[345]) name = decodeStr(buf, 345, 155)+'/'+name\n\n  var c = cksum(buf)\n\n  //checksum is still initial value if header was null.\n  if (c === 8*32) return null\n\n  //valid checksum\n  if (c !== decodeOct(buf, 148)) throw new Error('invalid header')\n\n  return {\n    name: name,\n    mode: mode,\n    uid: uid,\n    gid: gid,\n    size: size,\n    mtime: new Date(1000 * mtime),\n    type: toType(typeflag),\n    linkname: linkname,\n    uname: uname,\n    gname: gname,\n    devmajor: devmajor,\n    devminor: devminor\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-package/node_modules/tar-stream/pack.js":"var util = require('util')\nvar eos = require('end-of-stream')\nvar headers = require('./headers')\n\nvar Readable = require('readable-stream').Readable\nvar Writable = require('readable-stream').Writable\nvar PassThrough = require('readable-stream').PassThrough\n\nvar END_OF_TAR = new Buffer(1024)\nEND_OF_TAR.fill(0)\n\nvar noop = function() {}\n\nvar overflow = function(self, size) {\n  size &= 511\n  if (size) self.push(END_OF_TAR.slice(0, 512 - size))\n}\n\nvar Sink = function(to) {\n  Writable.call(this)\n  this.written = 0\n  this._to = to\n  this._destroyed = false\n}\n\nutil.inherits(Sink, Writable)\n\nSink.prototype._write = function(data, enc, cb) {\n  this.written += data.length\n  if (this._to.push(data)) return cb()\n  this._to._drain = cb\n}\n\nSink.prototype.destroy = function() {\n  if (this._destroyed) return\n  this._destroyed = true\n  this.emit('close')\n}\n\nvar Void = function() {\n  Writable.call(this)\n  this._destroyed = false\n}\n\nutil.inherits(Void, Writable)\n\nVoid.prototype._write = function(data, enc, cb) {\n  cb(new Error('No body allowed for this entry'))\n}\n\nVoid.prototype.destroy = function() {\n  if (this._destroyed) return\n  this._destroyed = true\n  this.emit('close')\n}\n\nvar Pack = function(opts) {\n  if (!(this instanceof Pack)) return new Pack(opts)\n  Readable.call(this, opts)\n\n  this._drain = noop\n  this._finalized = false\n  this._finalizing = false\n  this._destroyed = false\n  this._stream = null\n}\n\nutil.inherits(Pack, Readable)\n\nPack.prototype.entry = function(header, buffer, callback) {\n  if (this._stream) throw new Error('already piping an entry')\n  if (this._finalized || this._destroyed) return\n\n  if (typeof buffer === 'function') {\n    callback = buffer\n    buffer = null\n  }\n\n  if (!callback) callback = noop\n\n  var self = this\n\n  if (!header.size)  header.size = 0\n  if (!header.type)  header.type = 'file'\n  if (!header.mode)  header.mode = header.type === 'directory' ? 0755 : 0644\n  if (!header.uid)   header.uid = 0\n  if (!header.gid)   header.gid = 0\n  if (!header.mtime) header.mtime = new Date()\n\n  if (typeof buffer === 'string') buffer = new Buffer(buffer)\n  if (Buffer.isBuffer(buffer)) {\n    header.size = buffer.length\n    this._encode(header)\n    this.push(buffer)\n    overflow(self, header.size)\n    process.nextTick(callback)\n    return new Void()\n  }\n  if (header.type !== 'file' && header.type !== 'contigious-file') {\n    this._encode(header)\n    process.nextTick(callback)\n    return new Void()\n  }\n\n  var sink = new Sink(this)\n\n  this._encode(header)\n  this._stream = sink\n\n  eos(sink, function(err) {\n    self._stream = null\n\n    if (err) { // stream was closed\n      self.destroy()\n      return callback(err)\n    }\n\n    if (sink.written !== header.size) { // corrupting tar\n      self.destroy()\n      return callback(new Error('size mismatch'))\n    }\n\n    overflow(self, header.size)\n    if (self._finalizing) self.finalize()\n    callback()\n  })\n\n  return sink\n}\n\nPack.prototype.finalize = function() {\n  if (this._stream) {\n    this._finalizing = true\n    return\n  }\n\n  if (this._finalized) return\n  this._finalized = true\n  this.push(END_OF_TAR)\n  this.push(null)\n}\n\nPack.prototype.destroy = function(err) {\n  if (this._destroyed) return\n  this._destroyed = true\n\n  if (err) this.emit('error', err)\n  this.emit('close')\n  if (this._stream && this._stream.destroy) this._stream.destroy()\n}\n\nPack.prototype._encode = function(header) {\n  var buf = headers.encode(header)\n  if (buf) this.push(buf)\n  else this._encodePax(header)\n}\n\nPack.prototype._encodePax = function(header) {\n  var paxHeader = headers.encodePax({\n    name: header.name,\n    linkname: header.linkname\n  })\n\n  var newHeader = {\n    name: 'PaxHeader',\n    mode: header.mode,\n    uid: header.uid,\n    gid: header.gid,\n    size: paxHeader.length,\n    mtime: header.mtime,\n    type: 'pax-header',\n    linkname: header.linkname && 'PaxHeader',\n    uname: header.uname,\n    gname: header.gname,\n    devmajor: header.devmajor,\n    devminor: header.devminor\n  }\n\n  this.push(headers.encode(newHeader))\n  this.push(paxHeader)\n  overflow(this, paxHeader.length)\n\n  newHeader.size = header.size\n  newHeader.type = header.type\n  this.push(headers.encode(newHeader))\n}\n\nPack.prototype._read = function(n) {\n  var drain = this._drain\n  this._drain = noop\n  drain()\n}\n\nmodule.exports = Pack\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-package/node_modules/end-of-stream/index.js":"var once = require('once');\n\nvar noop = function() {};\n\nvar isRequest = function(stream) {\n\treturn stream.setHeader && typeof stream.abort === 'function';\n};\n\nvar eos = function(stream, opts, callback) {\n\tif (typeof opts === 'function') return eos(stream, null, opts);\n\tif (!opts) opts = {};\n\n\tcallback = once(callback || noop);\n\n\tvar ws = stream._writableState;\n\tvar rs = stream._readableState;\n\tvar readable = opts.readable || (opts.readable !== false && stream.readable);\n\tvar writable = opts.writable || (opts.writable !== false && stream.writable);\n\n\tvar onlegacyfinish = function() {\n\t\tif (!stream.writable) onfinish();\n\t};\n\n\tvar onfinish = function() {\n\t\twritable = false;\n\t\tif (!readable) callback();\n\t};\n\n\tvar onend = function() {\n\t\treadable = false;\n\t\tif (!writable) callback();\n\t};\n\n\tvar onclose = function() {\n\t\tif (readable && !(rs && rs.ended)) return callback(new Error('premature close'));\n\t\tif (writable && !(ws && ws.ended)) return callback(new Error('premature close'));\n\t};\n\n\tvar onrequest = function() {\n\t\tstream.req.on('finish', onfinish);\n\t};\n\n\tif (isRequest(stream)) {\n\t\tstream.on('complete', onfinish);\n\t\tstream.on('abort', onclose);\n\t\tif (stream.req) onrequest();\n\t\telse stream.on('request', onrequest);\n\t} else if (writable && !ws) { // legacy streams\n\t\tstream.on('end', onlegacyfinish);\n\t\tstream.on('close', onlegacyfinish);\n\t}\n\n\tstream.on('end', onend);\n\tstream.on('finish', onfinish);\n\tif (opts.error !== false) stream.on('error', callback);\n\tstream.on('close', onclose);\n\n\treturn function() {\n\t\tstream.removeListener('complete', onfinish);\n\t\tstream.removeListener('abort', onclose);\n\t\tstream.removeListener('request', onrequest);\n\t\tif (stream.req) stream.req.removeListener('finish', onfinish);\n\t\tstream.removeListener('end', onlegacyfinish);\n\t\tstream.removeListener('close', onlegacyfinish);\n\t\tstream.removeListener('finish', onfinish);\n\t\tstream.removeListener('end', onend);\n\t\tstream.removeListener('error', callback);\n\t\tstream.removeListener('close', onclose);\n\t};\n};\n\nmodule.exports = eos;","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-package/node_modules/end-of-stream/node_modules/once/once.js":"var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-package/node_modules/pump/index.js":"var once = require('once');\nvar eos = require('end-of-stream');\nvar fs = require('fs'); // we only need fs to get the ReadStream and WriteStream prototypes\n\nvar noop = function() {};\n\nvar isFn = function(fn) {\n\treturn typeof fn === 'function';\n};\n\nvar isFS = function(stream) {\n\treturn (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);\n};\n\nvar isRequest = function(stream) {\n\treturn stream.setHeader && isFn(stream.abort);\n};\n\nvar destroyer = function(stream, reading, writing, callback) {\n\tcallback = once(callback);\n\n\tvar closed = false;\n\tstream.on('close', function() {\n\t\tclosed = true;\n\t});\n\n\teos(stream, {readable:reading, writable:writing}, function(err) {\n\t\tif (err) return callback(err);\n\t\tclosed = true;\n\t\tcallback();\n\t});\n\n\tvar destroyed = false;\n\treturn function(err) {\n\t\tif (closed) return;\n\t\tif (destroyed) return;\n\t\tdestroyed = true;\n\n\t\tif (isFS(stream)) return stream.close(); // use close for fs streams to avoid fd leaks\n\t\tif (isRequest(stream)) return stream.abort(); // request.destroy just do .end - .abort is what we want\n\n\t\tif (isFn(stream.destroy)) return stream.destroy();\n\n\t\tcallback(err || new Error('stream was destroyed'));\n\t};\n};\n\nvar call = function(fn) {\n\tfn();\n};\n\nvar pipe = function(from, to) {\n\treturn from.pipe(to);\n};\n\nvar pump = function() {\n\tvar streams = Array.prototype.slice.call(arguments);\n\tvar callback = isFn(streams[streams.length-1] || noop) && streams.pop() || noop;\n\n\tif (Array.isArray(streams[0])) streams = streams[0];\n\tif (streams.length < 2) throw new Error('pump requires two streams per minimum');\n\n\tvar error;\n\tvar destroys = streams.map(function(stream, i) {\n\t\tvar reading = i < streams.length-1;\n\t\tvar writing = i > 0;\n\t\treturn destroyer(stream, reading, writing, function(err) {\n\t\t\tif (!error) error = err;\n\t\t\tif (err) destroys.forEach(call);\n\t\t\tif (reading) return;\n\t\t\tdestroys.forEach(call);\n\t\t\tcallback(error);\n\t\t});\n\t});\n\n\treturn streams.reduce(pipe);\n};\n\nmodule.exports = pump;","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-package/node_modules/once/once.js":"module.exports = once\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return\n    f.called = true\n    return fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-package/node_modules/tar-fs/node_modules/mkdirp/index.js":"var path = require('path');\nvar fs = require('fs');\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, mode, f, made) {\n    if (typeof mode === 'function' || mode === undefined) {\n        f = mode;\n        mode = 0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    var cb = f || function () {};\n    if (typeof mode === 'string') mode = parseInt(mode, 8);\n    p = path.resolve(p);\n\n    fs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), mode, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, mode, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                fs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, mode, made) {\n    if (mode === undefined) {\n        mode = 0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    if (typeof mode === 'string') mode = parseInt(mode, 8);\n    p = path.resolve(p);\n\n    try {\n        fs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), mode, made);\n                sync(p, mode, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = fs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-main/index.js":"/**\n * Module Dependencies\n */\n\nvar type = require('component-type');\nvar path = require('path');\nvar extname = path.extname;\n\n/**\n * Regexps\n */\n\nvar rsupport = /^(js|css)$/;\n\n/**\n * Export `coerce`\n */\n\nmodule.exports = coerce;\n\n/**\n * Coerce the \"main\"'s from a manifest's JSON\n *\n * @param {Object} json\n * @return {Array}\n * @api private\n */\n\nfunction coerce(json, type) {\n  return type\n    ? dependency(json, type)\n    : entry(json);\n};\n\n/**\n * Get the mains from an entry\n *\n * @param {Object} json\n * @return {Array}\n * @api private\n */\n\nfunction entry(json) {\n  var script = (json.scripts || [])[0];\n  var style = (json.styles || [])[0];\n  var main = json.main;\n  var entries = [];\n\n  switch(type(main)) {\n    case 'object': entries = entries.concat(values(main)); break;\n    case 'array': entries = entries.concat(main); break;\n    case 'string': entries.push(main); break;\n  }\n\n  if (!main || compat(json)) {\n    switch (extension(main)) {\n      case 'css': script && entries.push(script); break;\n      case 'js': style && entries.push(style); break;\n      case '':\n        script && entries.push(script);\n        style && entries.push(style);\n        break;\n    }\n  }\n\n  return entries;\n}\n\n/**\n * Get the main from a dependency\n *\n * @param {Object} json\n * @param {String} ext\n * @return {String|Boolean}\n */\n\nfunction dependency(json, ext) {\n  var script = (json.scripts || [])[0];\n  var style = (json.styles || [])[0];\n  var main = json.main;\n\n  if (!main || compat(json)) {\n    if (ext == extension(json.main)) return main;\n    else if (ext == extension(style)) return style;\n    else if (ext == extension(script)) return script;\n    else return false;\n  }\n\n  switch(type(main)) {\n    case 'object': return main[ext] || false;\n    case 'string': return main;\n  }\n\n  return false;\n}\n\n/**\n * Compatibility\n *\n * @param {Object} json\n * @return {Boolean}\n */\n\nfunction compat(json) {\n  var main = json.main;\n  var ext = extension(main);\n\n  return rsupport.test(ext)\n    && 'string' == type(json.main);\n}\n\n/**\n * Get the values of an object\n *\n * @param {Object} obj\n * @return {Array}\n * @api private\n */\n\nfunction values(obj) {\n  return Object.keys(obj).map(function(k) {\n    return obj[k];\n  });\n}\n\n/**\n * Get the extension\n *\n * @param {String} path\n * @return {String}\n * @api private\n */\n\nfunction extension(path) {\n  if (typeof path !== 'string') return '';\n  return extname(path).slice(1);\n}\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-parse/index.js":"\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('duo-parse');\n\n/**\n * Export `parse`\n */\n\nmodule.exports = parse;\n\n/**\n * Parse the given `slug`.\n *\n * @param {String} slug\n * @return {Object}\n * @api public\n */\n\nfunction parse(slug) {\n  var obj = {};\n  var at, colon, parts;\n\n  if (~(at = slug.indexOf('@'))) {\n    var split = slug.substring(at + 1);\n    parts = slug.substring(0, at).split('/');\n    if (~(colon = split.indexOf(':'))) {\n      // user/repo@version:path\n      obj.ref = split.substring(0, colon);\n      obj.path = split.substring(colon + 1);\n    } else {\n      // user/repo@version\n      obj.ref = split;\n    }\n  } else {\n    if (~(colon = slug.indexOf(':'))) {\n      // user/repo:path\n      obj.path = slug.substring(colon + 1);\n      parts = slug.substring(0, colon).split('/');\n    } else {\n      // user/repo\n      parts = slug.split('/');\n    }\n  }\n\n  if (parts.length === 3) {\n    // provider.com/someuser/somerepo\n    obj.provider = parts[0];\n    obj.user = parts[1];\n    obj.repo = parts[2];\n  } else if (parts.length === 2) {\n    // someuser/somerepo\n    obj.user = parts[0];\n    obj.repo = parts[1];\n  } else {\n    // somerepo\n    obj.repo = parts[0];\n  }\n\n  obj.provider = obj.provider || 'github.com';\n\n  debug('parsed %s', slug, obj);\n  return obj;\n}\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo/lib/cache.js":"\n/**\n * Module dependencies.\n */\n\nvar Cache = require('duo-cache');\nvar debug = require('debug')('duo:cache');\nvar each = require('co-each');\nvar values = require('object-values');\n\n/**\n * Manages the available instances of the cache, allowing multiple\n * duo builders to operate on the same root dir in parallel.\n */\n\nvar instances = {};\n\nexports = module.exports = function (file) {\n  if (!(file in instances)) {\n    debug('creating new cache instance');\n    instances[file] = new Cache(file);\n  }\n\n  return instances[file];\n};\n\nexports.clean = function* () {\n  debug('clearing out cache instance list');\n  yield each(values(instances), function* (instance) {\n    yield instance.clean();\n  });\n  instances = {};\n};\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-cache/index.js":"\n/**\n * Module dependiencs.\n */\n\nvar debug = require('debug')('duo-cache');\nvar level = require('level');\nvar unyield = require('unyield');\nvar values = require('object-values');\nvar wrap = require('co-level');\n\n/**\n * Single export.\n */\n\nmodule.exports = Cache;\n\n/**\n * Represents a cache for duo to use during builds.\n *\n * @constructor\n * @param {String} location\n */\n\nfunction Cache(location) {\n  debug('new instance', location);\n  this.location = location;\n}\n\n/**\n * Initializes the instance and opens the database.\n */\n\nCache.prototype.initialize = unyield(function *() {\n  if (!this.leveldb) {\n    this.leveldb = wrap(level(this.location, {\n      keyEncoding: 'json',\n      valueEncoding: 'json'\n    }));\n  }\n\n  yield this.leveldb.open();\n});\n\n/**\n * Helper for getting a value from the cache. Any arguments are\n * forwarded to leveldb.\n *\n * @param {Array:String} key\n * @param {Object} [options]\n * @return {Mixed}\n */\n\nCache.prototype.get = unyield(function *(key, options) {\n  var db = this.leveldb;\n\n  try {\n    debug('get: %j', key);\n    return yield db.get(key, options);\n  } catch (err) {\n    debug('key %j not found', key);\n    return false;\n  }\n});\n\n/**\n * Helper for setting a value in the cache. Any arguments are\n * forwarded to leveldb.\n *\n * @param {Array:String} key\n * @param {Mixed} value\n * @param {Object} [options]\n * @return {Mixed}\n */\n\nCache.prototype.put = unyield(function *(key, value, options) {\n  var db = this.leveldb;\n  debug('put: %j', key);\n  return yield db.put(key, value, options);\n});\n\n/**\n * Helper for invalidating a value in the cache. Any arguments are\n * forwarded to leveldb.\n *\n * @return {Mixed}\n */\n\nCache.prototype.del = unyield(function *(key, options) {\n  var db = this.leveldb;\n  debug('del: %j', key);\n  return yield db.del(key, options);\n});\n\n/**\n * Reads the list of files into memory.\n *\n * TODO: this should probably be renamed to something more\n * descriptive in the future.\n *\n * TODO: refactor this to be more co-like.\n *\n * @returns {Promise}\n */\n\nCache.prototype.read = unyield(function *() {\n  debug('reading mapping from disk');\n  var db = this.leveldb;\n  var ret = {};\n\n  return yield function (done) {\n    db.createReadStream()\n      .on('error', function (err) {\n        debug('error reading', err.stack);\n        done(err);\n      })\n      .on('data', function (data) {\n        if (data.key[0] !== 'file') return;\n        var file = data.value;\n        debug('file read', file.id);\n        ret[file.id] = file;\n      })\n      .on('end', function () {\n        done(null, ret);\n      });\n  };\n});\n\n/**\n * Accepts an in-memory mapping and updates the specified files in the cache.\n *\n * TODO: this should probably be made a little more generic in the future.\n *\n * @param {Object} mapping  The list of files to update\n * @returns {Promise}\n */\n\nCache.prototype.update = unyield(function *(mapping) {\n  var db = this.leveldb;\n\n  var ops = values(mapping).map(function (file) {\n    return { type: 'put', key: [ 'file', file.id ], value: file };\n  }, this);\n\n  debug('updating %d files', ops.length);\n  return yield db.batch(ops);\n});\n\n/**\n * Get/Set a single file's cache data.\n *\n * @param {String} id    The key to use for the database\n * @param {Object} data  The value to store\n * @returns {Promise}\n */\n\nCache.prototype.file = unyield(function *(id, data) {\n  var key = [ 'file', id ];\n\n  if (typeof data !== 'undefined') {\n    return yield this.put(key, data);\n  } else {\n    return yield this.get(key);\n  }\n});\n\n/**\n * Get/Set a cache item on behalf of a plugin.\n *\n * @param {String} name  The plugin's name\n * @param {String} id    The key to use for the database\n * @param {Object} data  The value to store\n * @returns {Promise}\n */\n\nCache.prototype.plugin = unyield(function *(name, id, data) {\n  var key = [ 'plugin', name, id ];\n\n  if (typeof data !== 'undefined') {\n    return yield this.put(key, data);\n  } else {\n    return yield this.get(key);\n  }\n});\n\n/**\n * Wipes out the cache from disk.\n *\n * @returns {Promise}\n */\n\nCache.prototype.clean = unyield(function *() {\n  var db = this.leveldb;\n  var location = this.location;\n\n  debug('cleaning database');\n  yield db.close();\n  yield function (done) {\n    level.destroy(location, done);\n  };\n});\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-pack/lib/index.js":"\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('duo-pack');\n\n/**\n * Expose `Pack`\n */\n\nmodule.exports = Pack;\n\n/**\n * Default Packs\n */\n\nPack.js = require('./js');\nPack.css = require('./css');\n\n/**\n * Initialize `Pack`\n *\n * @param {Object} mapping\n * @param {Object} opts\n * @return {Pack}\n * @api public\n */\n\nfunction Pack(mapping, opts) {\n  if (!(this instanceof Pack)) return new Pack(mapping, opts);\n\n  debug('initialized');\n  this.opts = opts || {};\n  this.mapping = mapping;\n  this.sourceMap(false);\n}\n\n/**\n * Development\n *\n * @param {Boolean} develop\n * @return {Pack}\n * @api public\n */\n\nPack.prototype.sourceMap = function(value) {\n  if (typeof value === 'undefined') return this.sm;\n  debug('setting source-map', value);\n  this.sm = value;\n  return this;\n};\n\n/**\n * Pack the assets\n *\n * @param {String} entry\n * @return {Pack}\n * @api public\n */\n\nPack.prototype.pack = function(entry) {\n  debug('packing', entry);\n  var mapping = this.mapping;\n  var dep = mapping[entry];\n  var type = dep.type;\n\n  // ensure we have a fn for type\n  if (!Pack[type]) return false;\n\n  // pack the source\n  return Pack[type](dep, mapping, this).run();\n};\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-pack/lib/js/index.js":"/**\n * Module Dependencies\n */\n\nvar debug = require('debug')('duo-pack:js');\nvar sourcemap = require('./sourcemap');\nvar fmt = require('util').format;\nvar req = require('./require');\nvar stringify = JSON.stringify;\nvar umd = require('./umd');\n\n/**\n * Expose `JS`\n */\n\nmodule.exports = JS;\n\n/**\n * Initialize `JS`\n *\n * @param {String} entry\n * @param {Object} mapping\n * @param {Pack} pack\n * @return {Function}\n * @api public\n */\n\nfunction JS(entry, mapping, pack) {\n  if (!(this instanceof JS)) return new JS(entry, mapping, pack);\n\n  debug('initialized');\n  this.sm = this.sourceMap(entry.id, pack.sourceMap());\n  this.mapping = mapping;\n  this.opts = pack.opts;\n  this.entry = entry;\n  this.pack = pack;\n  this.ids = {};\n  this.uid = 0;\n}\n\n/**\n * Sets up the source-map.\n *\n * @param {String} entry          the entry file id\n * @param {Boolean|String} value  true/false/'inline'\n */\n\nJS.prototype.sourceMap = function (entry, state) {\n  if (!state) return false;\n  return sourcemap(entry, state === 'inline');\n};\n\n/**\n * Packs the entry/mapping into a single result object.\n *\n * @returns {Object}\n * @api public\n */\n\nJS.prototype.run = function () {\n  debug('running');\n  return {\n    code: this.code(),\n    map: this.map()\n  };\n};\n\n/**\n * Compile the mapping to a string\n *\n * @return {String}\n */\n\nJS.prototype.code = function() {\n  var str = '%s({\\n%s}, {}, %s)';\n  var entry = this.entry;\n\n  // add require to source-map\n  if (this.sm) this.sm.file('require.js', req);\n\n  // build the source\n  var src = this.pkg(entry);\n\n  // global support\n  var id = this.remap(entry).id;\n  var m = {};\n  m[id] = entry.global || '';\n\n  // umd support\n  if (this.opts.umd && entry.name) {\n    str = fmt('%s(%s);', umd\n      .replace(/:entry/g, entry.name)\n      .replace(/:id/g, id)\n      , str);\n  }\n\n  if (this.sm) str += '\\n\\n' + this.sm.comment();\n\n  return fmt(str, req, join(src), stringify(m));\n};\n\n/**\n * Returns the generated source-map.\n *\n * @reutrns {Object}\n */\n\nJS.prototype.map = function () {\n  if (!this.sm) return false;\n  if (this.sm.inline) return false;\n  return this.sm.external();\n};\n\n/**\n * Package the deps\n *\n * @param {Object} dep\n * @param {Object} out (private)\n * @return {String}\n * @api private\n */\n\nJS.prototype.pkg = function(dep, out) {\n  debug('packaging', dep.id);\n  out = out || {};\n\n  if (out[dep.id]) return out;\n\n  var id = dep.id;\n  var src = dep.src;\n  var deps = dep.deps;\n  var remapped = this.remap(dep);\n  var str = fmt('%d: [%s, %s]', remapped.id, wrap(src), stringify(remapped.deps));\n\n  // add to out\n  out[id] = str;\n\n  // add file to sourcemap\n  if (this.sm) this.sm.file(id, src, str);\n\n  // recurse through dep's deps\n  for (var d in deps) {\n    this.pkg(this.mapping[deps[d]], out);\n  }\n\n  return out;\n};\n\n/**\n * Remap JSON file paths to uids\n *\n * @param {Object} dep\n * @return {Object}\n * @api private\n */\n\nJS.prototype.remap = function(dep) {\n  debug('remapping', dep.id);\n  var out = {};\n\n  out.id = this.id(dep.id);\n  out.deps = {};\n\n  for (var req in dep.deps) {\n    out.deps[req] = this.id(dep.deps[req]);\n  }\n\n  return out;\n};\n\n/**\n * Get or set the uid\n *\n * @param {String} file\n * @return {Number}\n * @api private\n */\n\nJS.prototype.id = function(file) {\n  this.ids[file] = this.ids[file] || ++this.uid;\n  return this.ids[file];\n};\n\n/**\n * Wrap the source in a function\n *\n * @param {String} src\n * @return {String}\n * @api private\n */\n\nfunction wrap(src) {\n  return fmt('function(require, module, exports) {\\n%s\\n}', src);\n}\n\n/**\n * Join the sources\n *\n * @param {Object} obj\n * @return {String}\n * @api private\n */\n\nfunction join(obj) {\n  var out = [];\n  for (var id in obj) out.push(obj[id]);\n  return out.join(',\\n');\n}\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-pack/lib/js/sourcemap.js":"/**\n * Module dependencies\n */\n\nvar debug = require('debug')('duo-pack:js:sourcemap');\nvar sourcemap = require('combine-source-map');\nvar convert = require('convert-source-map');\nvar path = require('path');\n\n/**\n * Export `Sourcemap`\n */\n\nmodule.exports = Sourcemap;\n\n/**\n * Initialize `Sourcemap`\n */\n\nfunction Sourcemap(entry, inline) {\n  if (!(this instanceof Sourcemap)) return new Sourcemap(entry, inline);\n\n  debug('initialized');\n  this.sm = sourcemap.create(entry, '/duo');\n  this.inline = !!inline;\n  this.entry = entry;\n  this.lineno = 0;\n}\n\n/**\n * Add a file\n *\n * @param {String} file\n * @param {String} src\n * @api public\n */\n\nSourcemap.prototype.file = function(id, src, wrapped) {\n  debug('adding file', id);\n  var offset = wrapperOffset(src, wrapped);\n  var file = path.resolve('/', id);\n  this.sm.addFile({ sourceFile: file, source: src }, { line: this.lineno + offset });\n  this.lineno += lineno(wrapped || src);\n};\n\n/**\n * Render a source-map comment.\n *\n * @return {String}\n * @api public\n */\n\nSourcemap.prototype.comment = function() {\n  return this.inline\n    ? this.sm.comment()\n    : '//# sourceMappingURL=' + path.basename(this.entry) + '.map';\n};\n\n/**\n * Render an external source-map file.\n *\n * @return {String}\n * @api public\n */\n\nSourcemap.prototype.external = function () {\n  return convert.fromBase64(this.sm.base64()).toJSON();\n};\n\n/**\n * Get the number of lines\n *\n * @param {String} src\n * @return {Number}\n * @api private\n */\n\nfunction lineno(src) {\n  if (!src) return 0;\n  var m = src.match(/\\n/g);\n  return m ? m.length + 1 : 0;\n}\n\n/**\n * Get the number of lines prepended by wrapper\n *\n * @param {String} src\n * @param {String} wrapper\n * @return {Number}\n * @api private\n */\n\nfunction wrapperOffset(src, wrapped) {\n  if (!src || (src && !wrapped)) return 0;\n  return wrapped.substr(0, wrapped.indexOf(src)).match(/\\n/g).length;\n}\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-pack/node_modules/convert-source-map/index.js":"'use strict';\nvar fs = require('fs');\nvar path = require('path');\n\nvar commentRx = /^\\s*\\/(?:\\/|\\*)[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+;)?base64,(.*)$/mg;\nvar mapFileCommentRx =\n  // //# sourceMappingURL=foo.js.map                       /*# sourceMappingURL=foo.js.map */\n  /(?:\\/\\/[@#][ \\t]+sourceMappingURL=(.+?)[ \\t]*$)|(?:\\/\\*[@#][ \\t]+sourceMappingURL=([^\\*]+?)[ \\t]*(?:\\*\\/){1}[ \\t]*$)/mg\n\nfunction decodeBase64(base64) {\n  return new Buffer(base64, 'base64').toString();\n}\n\nfunction stripComment(sm) {\n  return sm.split(',').pop();\n}\n\nfunction readFromFileMap(sm, dir) {\n  // NOTE: this will only work on the server since it attempts to read the map file\n\n  var r = mapFileCommentRx.exec(sm);\n  mapFileCommentRx.lastIndex = 0;\n  \n  // for some odd reason //# .. captures in 1 and /* .. */ in 2\n  var filename = r[1] || r[2];\n  var filepath = path.join(dir, filename);\n\n  try {\n    return fs.readFileSync(filepath, 'utf8');\n  } catch (e) {\n    throw new Error('An error occurred while trying to read the map file at ' + filepath + '\\n' + e);\n  }\n}\n\nfunction Converter (sm, opts) {\n  opts = opts || {};\n  try {\n    if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);\n    if (opts.hasComment) sm = stripComment(sm);\n    if (opts.isEncoded) sm = decodeBase64(sm);\n    if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);\n\n    this.sourcemap = sm;\n  } catch(e) {\n    console.error(e);\n    return null;\n  }\n}\n\nConverter.prototype.toJSON = function (space) {\n  return JSON.stringify(this.sourcemap, null, space);\n};\n\nConverter.prototype.toBase64 = function () {\n  var json = this.toJSON();\n  return new Buffer(json).toString('base64');\n};\n\nConverter.prototype.toComment = function () {\n  var base64 = this.toBase64();\n  return '//# sourceMappingURL=data:application/json;base64,' + base64;\n};\n\n// returns copy instead of original\nConverter.prototype.toObject = function () {\n  return JSON.parse(this.toJSON());\n};\n\nConverter.prototype.addProperty = function (key, value) {\n  if (this.sourcemap.hasOwnProperty(key)) throw new Error('property %s already exists on the sourcemap, use set property instead');\n  return this.setProperty(key, value);\n};\n\nConverter.prototype.setProperty = function (key, value) {\n  this.sourcemap[key] = value;\n  return this;\n};\n\nConverter.prototype.getProperty = function (key) {\n  return this.sourcemap[key];\n};\n\nexports.fromObject = function (obj) {\n  return new Converter(obj);\n};\n\nexports.fromJSON = function (json) {\n  return new Converter(json, { isJSON: true });\n};\n\nexports.fromBase64 = function (base64) {\n  return new Converter(base64, { isEncoded: true });\n};\n\nexports.fromComment = function (comment) {\n  comment = comment\n    .replace(/^\\/\\*/g, '//')\n    .replace(/\\*\\/$/g, '');\n\n  return new Converter(comment, { isEncoded: true, hasComment: true });\n};\n\nexports.fromMapFileComment = function (comment, dir) {\n  return new Converter(comment, { commentFileDir: dir, isFileComment: true, isJSON: true });\n};\n\n// Finds last sourcemap comment in file or returns null if none was found\nexports.fromSource = function (content) {\n  var m = content.match(commentRx);\n  commentRx.lastIndex = 0;\n  return m ? exports.fromComment(m.pop()) : null;\n};\n\n// Finds last sourcemap comment in file or returns null if none was found\nexports.fromMapFileSource = function (content, dir) {\n  var m = content.match(mapFileCommentRx);\n  mapFileCommentRx.lastIndex = 0;\n  return m ? exports.fromMapFileComment(m.pop(), dir) : null;\n};\n\nexports.removeComments = function (src) {\n  commentRx.lastIndex = 0;\n  return src.replace(commentRx, '');\n};\n\nexports.removeMapFileComments = function (src) {\n  mapFileCommentRx.lastIndex = 0;\n  return src.replace(mapFileCommentRx, '');\n};\n\nexports.__defineGetter__('commentRegex', function () {\n  commentRx.lastIndex = 0;\n  return commentRx; \n});\n\nexports.__defineGetter__('mapFileCommentRegex', function () {\n  mapFileCommentRx.lastIndex = 0;\n  return mapFileCommentRx; \n});\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-pack/lib/js/require.js":"\n/**\n * Expose `outer`.\n */\n\nmodule.exports = (function(){\n  return '(' + outer.toString() + ')';\n})();\n\n/**\n * Require `name` or `id`.\n *\n * @param {String|Number} id\n * @return {Function}\n * @api private\n */\n\nfunction outer(modules, cache, entries){\n\n  /**\n   * Global\n   */\n\n  var global = (function(){ return this; })();\n\n  /**\n   * Require `name`.\n   *\n   * @param {String} name\n   * @api public\n   */\n\n  function require(name){\n    if (cache[name]) return cache[name].exports;\n    if (modules[name]) return call(name, require);\n    throw new Error('cannot find module \"' + name + '\"');\n  }\n\n  /**\n   * Call module `id` and cache it.\n   *\n   * @param {Number} id\n   * @param {Function} require\n   * @return {Function}\n   * @api private\n   */\n\n  function call(id, require){\n    var m = cache[id] = { exports: {} };\n    var mod = modules[id];\n    var name = mod[2];\n    var fn = mod[0];\n    var threw = true;\n\n    try {\n      fn.call(m.exports, function(req){\n        var dep = modules[id][1][req];\n        return require(dep || req);\n      }, m, m.exports, outer, modules, cache, entries);\n      threw = false;\n    } finally {\n      if (threw) {\n        delete cache[id];\n      } else if (name) {\n        // expose as 'name'.\n        cache[name] = cache[id];\n      }\n    }\n\n    return cache[id].exports;\n  }\n\n  /**\n   * Require all entries exposing them on global if needed.\n   */\n\n  for (var id in entries) {\n    if (entries[id]) {\n      global[entries[id]] = require(id);\n    } else {\n      require(id);\n    }\n  }\n\n  /**\n   * Duo flag.\n   */\n\n  require.duo = true;\n\n  /**\n   * Expose cache.\n   */\n\n  require.cache = cache;\n\n  /**\n   * Expose modules\n   */\n\n  require.modules = modules;\n\n  /**\n   * Return newest require.\n   */\n\n   return require;\n}\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-pack/lib/js/umd.js":"/* eslint-env amd */\n\n/**\n * Expose `umd`\n */\n\nmodule.exports = (function(){\n  return '(' + umd + ')';\n})();\n\n/**\n * UMD.\n */\n\nfunction umd(require){\n  if (typeof exports === 'object') {\n    module.exports = require(':id');\n  } else if (typeof define === 'function' && (define.amd || define.cmd)) {\n    define(function(){ return require(':id'); });\n  } else {\n    this[':entry'] = require(':id');\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo-pack/lib/css/index.js":"/**\n * Module dependencies\n */\n\nvar debug = require('debug')('duo-pack:css');\nvar relative = require('path').relative;\nvar dirname = require('path').dirname;\nvar filedeps = require('file-deps');\n\n/**\n * Export `CSS`\n */\n\nmodule.exports = CSS;\n\n/**\n * Initialize `CSS`\n *\n * @param {Strign} entry\n * @param {Object} mapping\n * @param {Pack} pack\n * @return {CSS}\n * @api public\n */\n\nfunction CSS(entry, mapping, pack) {\n  if (!(this instanceof CSS)) return new CSS(entry, mapping, pack);\n\n  debug('initialized');\n  this.mapping = mapping;\n  this.entry = entry;\n  this.pack = pack;\n  this.deps = {};\n}\n\n/**\n * Compile the mapping to a string\n *\n * @return {String}\n * @api public\n */\n\nCSS.prototype.run = function() {\n  debug('running');\n  return {\n    code: this.code()\n  };\n};\n\n/**\n * Generate the CSS source code.\n *\n * @returns {String}\n */\n\nCSS.prototype.code = function () {\n  return this.pkg(this.entry).value;\n};\n\n/**\n * Package the deps\n *\n * @param {Object} file\n * @param {String} parent (private)\n * @param {Object} tokens (private)\n * @return {String}\n * @api private\n */\n\nCSS.prototype.pkg = function(file, parent, tokens) {\n  debug('packaging', file);\n  tokens = tokens || {};\n\n  var base = dirname(this.entry.id);\n  var mapping = this.mapping;\n  var deps = file.deps;\n  var src = file.src;\n\n  // pull in all the sources\n  // TODO: fix for infinite recursion\n  for (var d in deps) {\n    tokens[deps[d]] = tokens[deps[d]] || this.pkg(mapping[deps[d]], file, tokens);\n  }\n\n  // replace url(...) with relative path\n  if (typeof file.src === 'undefined') {\n    var path = relative(base, file.id);\n    return this.asset(path);\n  }\n\n  // replace @import and url(...)\n  src = filedeps(src, 'css', function(d) {\n    debug('rewriting import', d);\n    var id = deps[d];\n    var token = tokens[id] || {};\n    var val = token.value;\n\n    // only include source once, but include assets many times\n    if (token.type === 'source') tokens[id].value = '';\n\n    return val;\n  });\n\n  return this.source(src);\n};\n\n/**\n * Create a `asset` token\n *\n * @param {String} value\n * @return {Object}\n * @api private\n */\n\nCSS.prototype.asset = function(value) {\n  return { type: 'asset', value: value };\n};\n\n/**\n * Create a `source` token\n *\n * @param {String} value\n * @return {Object}\n * @api private\n */\n\nCSS.prototype.source = function(value) {\n  return { type: 'source', value: value };\n};\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo/lib/file.js":"\n/**\n * Module dependencies.\n */\n\nvar clone = require('component-clone');\nvar delegate = require('delegates');\nvar filedeps = require('file-deps');\nvar extend = require('extend.js');\nvar exists = require('co-exists');\nvar mask = require('json-mask');\nvar path = require('path');\nvar fs = require('co-fs');\n\nvar relative = path.relative;\nvar extname = path.extname;\nvar resolve = path.resolve;\n\n/**\n * Export `File`.\n */\n\nmodule.exports = File;\n\n/**\n * Fields in `duo.json`.\n */\n\nvar fields = 'id,type,mtime,src,deps,entry';\n\n/**\n * Initialize a new `File` with `attrs`.\n *\n * @param {Object} attrs\n * @param {Duo} duo\n * @return {File}\n * @api public\n */\n\nfunction File(attrs, duo) {\n  if (!(this instanceof File)) return new File(attrs, duo);\n  this.attrs = clone(attrs || {});\n  this.duo = duo;\n\n  var type = attrs.type ? '.' + attrs.type : '';\n  var path = attrs.path || 'source' + type;\n\n  // initial attrs\n  this.attrs.path = resolve(attrs.root, path);\n  this.attrs.type = attrs.type || extension(this.path);\n  this.attrs.id = relative(duo.root(), this.path);\n\n  // local vs remote\n  this.attrs.local = !!(attrs.entry || attrs.local);\n}\n\n/**\n * Delegate getters & setters to `this.attrs`.\n */\n\ndelegate(File.prototype, 'attrs')\n  .access('id')\n  .access('src')\n  .access('raw')\n  .access('type')\n  .access('root')\n  .access('path')\n  .access('entry')\n  .access('mtime')\n  .access('name');\n\n/**\n * Delegate methods back into our `duo` instance.\n */\n\ndelegate(File.prototype, 'duo')\n  .getter('plugins')\n  .method('include')\n  .method('included');\n\n/**\n * Parse the dependencies in `this.src`.\n *\n * - `filedeps` changes its parser based on the file type (css vs. js)\n *\n * @return {Array}\n * @api public\n */\n\nFile.prototype.dependencies = function () {\n  if (this.deps) return this.deps;\n  if (!this.src) return [];\n  this.deps = filedeps(this.src, this.type);\n  return this.deps;\n};\n\n/**\n * Load the files source, running any transforms before returning it.\n *\n * @return {File}\n * @api public\n */\n\nFile.prototype.load = function* () {\n  if (typeof this.src !== 'undefined') return this;\n\n  // read the file\n  var raw = this.raw;\n  if (raw == null) raw = yield fs.readFile(this.path, 'utf8');\n  this.attrs.src = raw;\n\n  // transform the file and update attributes\n  var entry = this.entry ? this : this.duo.entry();\n  var res = yield this.plugins.run(this, entry);\n  this.set(res[0].json());\n\n  return this;\n};\n\n/**\n * Check if the path to the file exists, unless we already have the raw source.\n *\n * @return {Boolean}\n * @api public\n */\n\nFile.prototype.exists = function* () {\n  if (this.raw != null) return true;\n  else return yield exists(this.path);\n};\n\n/**\n * Set additional `attrs` on the file.\n *\n * @param {Object} attrs\n * @return {File}\n * @api public\n */\n\nFile.prototype.set = function (attrs) {\n  extend(this.attrs, attrs || {});\n  return this;\n};\n\n/**\n * Get a JSON representation of the file.\n *\n * @return {Object}\n * @api public\n */\n\nFile.prototype.json =\nFile.prototype.toString = function () {\n  var json = clone(this.attrs);\n  if (!json.entry) delete json.entry;\n  return mask(json, fields);\n};\n\n/**\n * Get the mtime of a `path`, falling back to the current time.\n *\n * @param {String} path\n * @return {Number}\n * @api private\n */\n\nFile.prototype.modified = function* () {\n  try {\n    var stat = yield fs.stat(this.path);\n    this.attrs.mtime = stat.mtime.getTime();\n  } catch (e) {\n    var now = new Date();\n    this.attrs.mtime = now.getTime();\n  }\n\n  return this.mtime;\n};\n\n/**\n * Determine if a file is a local.\n *\n * @return {Boolean}\n */\n\nFile.prototype.local = function () {\n  if (this.attrs.entry) return true;\n  if (this.attrs.local) return !!this.attrs.local;\n  return false;\n};\n\n/**\n * Determine if a file is a remote (eg: not a local)\n */\n\nFile.prototype.remote = function () {\n  return !this.local();\n};\n\n/**\n * Get the extension of a `path`.\n *\n * @param {String} path\n * @return {String} ext\n * @api private\n */\n\nfunction extension(path) {\n  return extname(path).slice(1);\n}\n","/home/travis/build/npmtest/node-npmtest-duo/node_modules/duo/lib/util.js":"\n/**\n * Module dependencies.\n */\n\nvar detect = require('language-classifier');\nvar resolve = require('path').resolve;\nvar exists = require('fs').existsSync;\nvar stat = require('fs').statSync;\nvar netrc = require('node-netrc');\nvar glob = require('glob').sync;\nvar path = require('path');\n\n/**\n * Language mapping.\n */\n\nvar langmap = {\n  javascript: 'js',\n  css: 'css'\n};\n\n/**\n * Pull GH auth from ~/.netrc or $GH_TOKEN env.\n */\n\nexports.token = function () {\n  if ('GH_TOKEN' in process.env) return process.env.GH_TOKEN;\n\n  var auth = netrc('api.github.com');\n  if (auth && auth.password) return auth.password;\n\n  return false;\n};\n\n/**\n * Normalize entries list.\n *\n *  - expand globs\n *  - expand directories into list of all nested files\n *\n * @param {Array:String}\n * @return {Array:String}\n */\n\nexports.entries = function (root, list) {\n  return list.filter(globs).reduce(function (memo, entry) {\n    if (isDir(path.join(root, entry))) {\n      return memo.concat(listFiles(root, entry));\n    } else {\n      return memo.concat(entry);\n    }\n  }, []);\n};\n\n/**\n * Helper for collecting CLI params into a single array.\n *\n * @param {String} val\n * @param {Array:String} memo\n * @returns {Array:String}\n */\n\nexports.collect = function (val, memo) {\n  val.split(',').forEach(function (val) {\n    memo.push(val);\n  });\n\n  return memo;\n};\n\n/**\n * Find the root.\n *\n * @param {String} root\n * @param {String}\n */\n\nexports.findroot = function (root) {\n  var cwd = process.cwd();\n  if (root) return resolve(cwd, root);\n  var sep = path.sep;\n  var parts = cwd.split(sep);\n  var dir = cwd;\n\n  while (!exists(path.join(dir, 'component.json')) && parts.length > 1) {\n    parts.pop();\n    dir = parts.join(sep);\n  }\n\n  return parts.length <= 1\n    ? cwd\n    : dir;\n};\n\n/**\n * Detect the type of a source-file.\n *\n * @param {String} src\n * @returns {String}\n */\n\nexports.type = function (src) {\n  return langmap[detect(src)];\n};\n\n/**\n * Retrieve an array of plugins from `--use`.\n *\n * @param {Array:String} plugins\n * @return {Array:Function}\n */\n\nexports.plugins = function (root, plugins) {\n  return plugins.map(function (plugin) {\n    var local = resolve(root, plugin);\n    var npm = resolve(root, 'node_modules', plugin);\n    var cwd = resolve(process.cwd(), 'node_modules', plugin);\n    var mod;\n\n    if (exists(local)) mod = require(local);\n    else if (exists(local + '.js')) mod = require(local);\n    else if (exists(npm)) mod = require(npm);\n    else mod = require(cwd);\n\n    return Array.isArray(mod) ? mod : mod();\n  }, []);\n};\n\n\n/**\n * Filter out unexpanded globs.\n *\n * @param {String} entry\n * @return {Boolean}\n */\n\nfunction globs(path) {\n  return !/\\*/.test(path);\n}\n\n/**\n * Gets a list of all files within a directory recursively (and synchronously)\n *\n * @param {String} path\n * @return {Array:String}\n */\n\nfunction listFiles(root, dir, pattern) {\n  var opts = { cwd: root, nodir: true };\n  return glob(path.join(dir, pattern || '**/*'), opts);\n}\n\n/**\n * Simple hueristic to check if `path` is a directory.\n *\n * @param {String} path\n * @return {Boolean}\n */\n\nfunction isDir(path) {\n  try {\n    return stat(path).isDirectory();\n  } catch (e) {\n    return false;\n  }\n}\n"}